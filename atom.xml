<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星之所在</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-25T03:13:54.788Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>planet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>async/await 优雅的错误处理方法</title>
    <link href="http://yoursite.com/2019/01/02/async%E4%B8%8Eawait%20%E4%BC%98%E9%9B%85%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/02/async与await 优雅的错误处理方法/</id>
    <published>2019-01-02T02:20:10.000Z</published>
    <updated>2019-01-25T03:13:54.788Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下 async/await 在错误处理方面，主要使用 try/catch，像这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data is -&gt;'</span>, data)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这么看，感觉倒是没什么问题，如果是这样呢？有多个异步操作，需要对每个异步返回的 error 错误状态进行不同的处理，以下是示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchDataA = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is A'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchDataB = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is B'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchDataC = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is C'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataA = <span class="keyword">await</span> fetchDataA()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataA is -&gt;'</span>, dataA)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataB = <span class="keyword">await</span> fetchDataB()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataB is -&gt;'</span>, dataB)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataC = <span class="keyword">await</span> fetchDataC()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataC is -&gt;'</span>, dataC)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这样写代码里充斥着 try/catch，有代码洁癖的你能忍受的了吗？这时可能会想到只用一个 try/catch。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 这里 fetch 函数省略</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataA = <span class="keyword">await</span> fetchDataA()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataA is -&gt;'</span>, dataA)</span><br><span class="line">        <span class="keyword">const</span> dataB = <span class="keyword">await</span> fetchDataB()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataB is -&gt;'</span>, dataB)</span><br><span class="line">        <span class="keyword">const</span> dataC = <span class="keyword">await</span> fetchDataC()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataC is -&gt;'</span>, dataC)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">        <span class="comment">// 难道要定义 err 类型，然后判断吗？？</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * if (err.type === 'dataA') &#123;</span></span><br><span class="line"><span class="comment">         *  console.log('dataA err is', err)</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * ......</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>如果是这样写只会增加编码的复杂度，而且要多写代码，这个时候就应该想想怎么优雅的解决，<code>async/await</code> 本质就是 <code>promise</code> 的语法糖，既然是 promise 那么就可以使用 <code>then 函数</code>了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> data ).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>在上面写法中，如果 fetchData 返回 resolve 正确结果时，data 是我们要的结果，如果是 reject 了，发生错误了，那么 data 是错误结果，这显然是行不通的，再对其完善。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [err, data] = <span class="keyword">await</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data] ).catch(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>, err)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data'</span>, data)</span><br><span class="line">    <span class="comment">// err null</span></span><br><span class="line">    <span class="comment">// data fetch data is me</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>这样是不是好很多了呢，但是问题又来了，不能每个 await 都写这么长，写着也不方便也不优雅，再优化一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽离成公共方法</span></span><br><span class="line">    <span class="keyword">const</span> awaitWrap = <span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">            .then(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data])</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [err, data] = <span class="keyword">await</span> awaitWrap(fetchData())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>, err)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data'</span>, data)</span><br><span class="line">    <span class="comment">// err null</span></span><br><span class="line">    <span class="comment">// data fetch data is me</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>将对 await 处理的方法抽离成公共的方法，在使用 await 调用 awaitWrap 这样的方法是不是更优雅了呢。如果使用 typescript 实现大概是这个样子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function awaitWrap&lt;T, U = any&gt;(promise: Promise&lt;T&gt;): Promise&lt;[U | null, T | null]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">        .then&lt;[<span class="literal">null</span>, T]&gt;<span class="function">(<span class="params">(data: T</span>) =&gt;</span> [<span class="literal">null</span>, data])</span><br><span class="line">        .catch&lt;[U, <span class="literal">null</span>]&gt;(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类似的npm包有这个 save await-to-js 可以尝试下去安装玩玩</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下 async/await 在错误处理方面，主要使用 try/catch，像这样&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fetchData = &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            resolve(&lt;span class=&quot;string&quot;&gt;&#39;fetch data is me&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; data = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; fetchData()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;data is -&amp;gt;&#39;&lt;/span&gt;, data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(err) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;err is -&amp;gt;&#39;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="es7" scheme="http://yoursite.com/categories/es7/"/>
    
    
      <category term="es7" scheme="http://yoursite.com/tags/es7/"/>
    
  </entry>
  
  <entry>
    <title>面试资源</title>
    <link href="http://yoursite.com/2018/12/27/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2018/12/27/面试资源/</id>
    <published>2018-12-27T07:20:17.995Z</published>
    <updated>2018-12-27T07:21:46.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题相关"><a href="#面试题相关" class="headerlink" title="面试题相关"></a>面试题相关</h2><ul><li><p><a href="https://juejin.im/post/5aae076d6fb9a028cc6100a9" target="_blank" rel="noopener">前端面试考点多？看这几篇文章就够了</a></p></li><li><p><a href="https://juejin.im/post/5a998991f265da237f1dbdf9" target="_blank" rel="noopener">2018春招前端面试: 闯关记</a></p></li><li><p><a href="https://juejin.im/post/5a9b8417518825558251ce15" target="_blank" rel="noopener">记录面试中一些回答不够好的题</a></p></li><li><p><a href="https://juejin.im/post/5a961d496fb9a06356314a36" target="_blank" rel="noopener">前端知识集锦</a></p></li><li><p><a href="https://github.com/qiu-deqing/FE-interview" target="_blank" rel="noopener">收集的前端面试题和答案</a></p></li><li><p><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener">前端开发面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzUzOTM0MTE4OQ==&amp;mid=2247484010&amp;idx=1&amp;sn=552101d7c9476085e67aa88a5fea6850&amp;chksm=fac8ba80cdbf33963a2cd40c5c597098d39a5566c23865550780a0df0b8c57eb6bf88c5b0fc3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">前端面试题总结——综合问题</a></p><a id="more"></a></li><li><p><a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map" target="_blank" rel="noopener">面试图谱</a></p></li><li><p><a href="https://juejin.im/post/5b4d543ce51d4519610dea67" target="_blank" rel="noopener">记一次凉凉的小米面试</a></p></li><li><p><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Chinese" target="_blank" rel="noopener">前端工作面试问题</a></p></li><li><p><a href="https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/README.md" target="_blank" rel="noopener">前端面试手册</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/28428367" target="_blank" rel="noopener">前端基础面试题(JS部分)</a></p></li><li><p><a href="https://segmentfault.com/a/1190000015916686" target="_blank" rel="noopener">新鲜出炉的8月前端面试题-2018</a></p></li><li><p><a href="https://github.com/ElemeFE/node-interview" target="_blank" rel="noopener">Node.js 面试</a></p></li><li><p><a href="https://juejin.im/post/5b68f384f265da0fa00a3df0" target="_blank" rel="noopener">一点感悟：当走完所有大厂的实习面试后</a></p></li><li><p><a href="https://segmentfault.com/a/1190000015591521" target="_blank" rel="noopener">总结了17年初到18年初百场前端面试的面试经验(含答案)</a></p></li><li><p><a href="https://github.com/forrany/Web-Project" target="_blank" rel="noopener">前端面试&amp;笔试&amp;错题指南</a></p></li><li><p><a href="https://github.com/CyC2018/Interview-Notebook" target="_blank" rel="noopener">技术面试需要掌握的基础知识整理(偏后端，可以了解下)</a></p></li><li><p><a href="https://github.com/poetries/FE-Interview-Questions" target="_blank" rel="noopener">前端面试常考问题整理</a></p></li><li><p><a href="https://juejin.im/post/5b9770056fb9a05d2f3692ce" target="_blank" rel="noopener">记一次前端大厂面试</a></p></li><li><p><a href="https://juejin.im/post/5bb470295188255c5e66f88f" target="_blank" rel="noopener">百度阿里网易大疆等大小厂前端校招面经</a></p></li><li><p><a href="https://juejin.im/post/5b5193e6e51d4519133fa700" target="_blank" rel="noopener">19秋招面经</a></p></li><li><p><a href="https://juejin.im/post/5b7432076fb9a009820daa37" target="_blank" rel="noopener">19秋招面经续</a></p></li><li><p><a href="https://blog.ihoey.com/posts/Interview/2018-02-28-alibaba-interview.html" target="_blank" rel="noopener">2018阿里巴巴前端面试总结</a></p></li><li><p><a href="https://juejin.im/post/5ab70735f265da237a4cf9b1" target="_blank" rel="noopener">大厂前端面试考什么? </a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T9vM95jj1GX3kaCOMCUGIw" target="_blank" rel="noopener">2018大厂高级前端面试题汇总</a></p></li><li><p><a href="https://www.geekjc.com/ebook/detail/5ba5bcae7143880b09cb4d54/1537588096871" target="_blank" rel="noopener">前端常见面试题汇总</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/7ZahpAT95MnWw-BC0FHyAQ" target="_blank" rel="noopener">整理了近期阿里携程的面试题</a></p></li><li><p><a href="https://dwz.cn/TlJnk9AX" target="_blank" rel="noopener">三年前端，面试思考（头条蚂蚁美团offer）</a></p></li><li><p><a href="https://juejin.im/post/5befeb5051882511a8527dbe" target="_blank" rel="noopener">一年半经验，百度、有赞、阿里面试总结</a></p></li></ul><h2 id="简历相关"><a href="#简历相关" class="headerlink" title="简历相关"></a>简历相关</h2><ul><li><p><a href="https://github.com/Wscats/CV" target="_blank" rel="noopener">切图仔面试宝典</a></p></li><li><p><a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">程序员简历模板</a></p></li><li><p><a href="https://segmentfault.com/a/1190000016085001" target="_blank" rel="noopener">什么样的简历不会被丢进回收站</a></p></li></ul><h2 id="面试经验杂谈"><a href="#面试经验杂谈" class="headerlink" title="面试经验杂谈"></a>面试经验杂谈</h2><ul><li><p><a href="https://github.com/Aaaaaaaty/blog/issues/39" target="_blank" rel="noopener">记一次“失利后”经过半年准备通过阿里社招的经历与感悟</a></p></li><li><p><a href="https://segmentfault.com/a/1190000006950447" target="_blank" rel="noopener">SegmentFault 技术周刊 Vol.6 - 面试那些事儿</a></p></li><li><p><a href="https://segmentfault.com/a/1190000015720085" target="_blank" rel="noopener">关于面试的思考</a></p></li><li><p><a href="https://github.com/jawil/blog/issues/22" target="_blank" rel="noopener">面试分享：一年经验初探阿里巴巴前端社招</a></p></li><li><p><a href="https://juejin.im/post/5a64541bf265da3e2d338862" target="_blank" rel="noopener">16年毕业的前端er在杭州求职ing</a></p></li><li><p><a href="https://github.com/fex-team/interview-questions" target="_blank" rel="noopener">FEX 面试问题(面试官的角度)</a></p></li><li><p><a href="https://juejin.im/post/5b9bb659e51d450e6e0398a8" target="_blank" rel="noopener">社会汪聊聊那些年的面试与笔试</a></p></li><li><p><a href="https://juejin.im/post/5b984950f265da0afc2be3bf" target="_blank" rel="noopener">七年切图仔如何面试大厂web前端？</a></p></li><li><p><a href="https://juejin.im/post/5bbc54a2e51d450e5a7445b4" target="_blank" rel="noopener">如何轻松拿到淘宝前端 offer</a></p></li><li><p><a href="http://ijser.cn/2017-07-16-resume-selecting-experance/" target="_blank" rel="noopener">简历筛选经验总结</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OiroQJ-73KjP-t6PYaVWCQ" target="_blank" rel="noopener">如何在面试中介绍自己的项目经验</a></p></li><li><p><a href="https://juejin.im/post/5bca74cfe51d450e9163351b" target="_blank" rel="noopener">以面试官的角度来看 React 工作面试</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/I1snrlV3ZWvFxSGsY6N19g" target="_blank" rel="noopener">2018年底的前端跳槽潮中面试官希望看到什么亮点？</a></p></li><li><p><a href="https://juejin.im/post/5bf5610be51d452a1353b08d" target="_blank" rel="noopener">2019年前端面试都聊啥？一起来看看</a></p></li></ul><p><img src="./assets/Interview.png" alt="面试经验谈"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面试题相关&quot;&gt;&lt;a href=&quot;#面试题相关&quot; class=&quot;headerlink&quot; title=&quot;面试题相关&quot;&gt;&lt;/a&gt;面试题相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5aae076d6fb9a028cc6100a9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端面试考点多？看这几篇文章就够了&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a998991f265da237f1dbdf9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2018春招前端面试: 闯关记&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a9b8417518825558251ce15&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;记录面试中一些回答不够好的题&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a961d496fb9a06356314a36&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端知识集锦&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/qiu-deqing/FE-interview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;收集的前端面试题和答案&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端开发面试题&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzOTM0MTE4OQ==&amp;amp;mid=2247484010&amp;amp;idx=1&amp;amp;sn=552101d7c9476085e67aa88a5fea6850&amp;amp;chksm=fac8ba80cdbf33963a2cd40c5c597098d39a5566c23865550780a0df0b8c57eb6bf88c5b0fc3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端面试题总结——综合问题&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>知识锦集</title>
    <link href="http://yoursite.com/2018/12/27/%E7%9F%A5%E8%AF%86%E9%94%A6%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/27/知识锦集/</id>
    <published>2018-12-27T07:20:17.992Z</published>
    <updated>2018-12-27T07:22:32.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><h4 id="更早之前"><a href="#更早之前" class="headerlink" title="更早之前"></a>更早之前</h4><ul><li><p><a href="http://eux.baidu.com/blog/fe/%E5%88%A9%E7%94%A8-javascript-%E5%AE%9E%E7%8E%B0%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" target="_blank" rel="noopener">利用 javascript 实现富文本编辑器</a></p></li><li><p><a href="https://juejin.im/post/5965943ff265da6c30653879" target="_blank" rel="noopener">JS正则表达式完整教程</a></p></li><li><p><a href="https://juejin.im/post/5a6fce10f265da3e261c3c71" target="_blank" rel="noopener">从0.1+0.2=0.30000000000000004再看JS中的Number类型</a></p></li><li><p><a href="https://qiutc.me/post/cross-domain-collections.html" target="_blank" rel="noopener">前端跨域的整理</a></p><a id="more"></a></li><li><p><a href="https://juejin.im/post/59dc2b7a6fb9a0451869ae3a" target="_blank" rel="noopener">前端安全知识</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/34453198?group_id=957277540147056640" target="_blank" rel="noopener">从输入URL到页面加载的过程</a></p></li><li><p><a href="https://www.jianshu.com/p/616999666920" target="_blank" rel="noopener">虚拟DOM介绍</a></p></li><li><p><a href="http://imweb.io/topic/5aa54d6c16bc830d673d42ee" target="_blank" rel="noopener">React常见问题</a></p></li><li><p><a href="https://github.com/fouber/blog/issues/6" target="_blank" rel="noopener">大公司里怎样开发和部署前端代码</a></p></li><li><p><a href="https://huangxuan.me/2017/07/12/upgrading-eleme-to-pwa/" target="_blank" rel="noopener">饿了么的 PWA 升级实践</a></p></li><li><p><a href="https://xiaoiver.github.io/coding/2017/07/30/%E4%B8%BAvue%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E9%AA%A8%E6%9E%B6%E5%B1%8F.html" target="_blank" rel="noopener">为vue项目添加骨架屏</a></p></li><li><p><a href="https://www.cnblogs.com/chengduxiaoc/p/7718768.html" target="_blank" rel="noopener">打通前后端全栈开发node+vue进阶</a></p></li><li><p><a href="https://www.cnblogs.com/guoxianglei/p/7084506.html" target="_blank" rel="noopener">vue+axios 前端实现登录拦截</a></p></li></ul><h4 id="201808"><a href="#201808" class="headerlink" title="201808"></a>201808</h4><ul><li><p><a href="https://juejin.im/post/5b729909e51d45662434aef0" target="_blank" rel="noopener">开源库架构实战——从0到1搭建属于你自己的开源库</a></p></li><li><p><a href="https://juejin.im/post/5b70514251882560f75dcc16" target="_blank" rel="noopener">微前端的设计理念与实践初探</a></p></li><li><p><a href="https://juejin.im/post/5b29c3bde51d45588d4d7110" target="_blank" rel="noopener">浅谈使用 Vue 构建前端 10w+ 代码量的单页面应用开发底层</a></p></li><li><p><a href="https://github.com/jaywcjlove/onlinenetwork" target="_blank" rel="noopener">js判断是否断网了</a></p></li><li><p><a href="https://github.com/hbxeagle/rem" target="_blank" rel="noopener">了解真实的『REM』手机屏幕适配</a></p></li><li><p><a href="https://github.com/kejiacheng/kscreenshot" target="_blank" rel="noopener">web截图工具</a></p></li><li><p><a href="https://juejin.im/post/5b6d0c5cf265da0f504a837f" target="_blank" rel="noopener">从青铜到王者10个css3伪类使用技巧和运用，了解一哈</a></p></li></ul><h4 id="201809"><a href="#201809" class="headerlink" title="201809"></a>201809</h4><ul><li><p><a href="https://mp.weixin.qq.com/s/xMCIXn3ZnrQdhrXU4T7zSg" target="_blank" rel="noopener">电商设计手册之用户体系</a></p></li><li><p><a href="https://segmentfault.com/a/1190000016231512" target="_blank" rel="noopener">AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/43597829" target="_blank" rel="noopener">程序员职业生涯的6个阶段</a></p></li><li><p><a href="https://github.com/berwin/Blog/issues/25" target="_blank" rel="noopener">2018你应该知道的Web性能信息采集指南</a></p></li><li><p><a href="https://www.zcfy.cc/article/introduction-front-end-developer-handbook-2018" target="_blank" rel="noopener">2018年前端开发工作手册</a></p></li><li><p><a href="https://github.com/shiyuejs/knowledge" target="_blank" rel="noopener">前端知识要点记录</a></p></li><li><p><a href="https://mathiasbynens.be/notes/prototypes" target="_blank" rel="noopener">JavaScript引擎基础：优化原型</a></p></li><li><p><a href="https://juejin.im/post/5ba09fbc5188255c880ab4b0" target="_blank" rel="noopener">WePY - 小程序敏捷开发实践</a></p></li><li><p><a href="https://juejin.im/post/5ba1ba036fb9a05d3155056c" target="_blank" rel="noopener">美团外卖小程序的探索和实践</a></p></li><li><p><a href="https://juejin.im/post/5ba2fa43e51d450e5d0b0676" target="_blank" rel="noopener">云开发初探 —— 更简便的小程序开发模式</a></p></li><li><p><a href="https://juejin.im/post/5a2e5f0851882575d42f5609" target="_blank" rel="noopener">import、require、export、module.exports 混合使用详解</a></p></li><li><p><a href="http://top.css88.com/archives/854" target="_blank" rel="noopener">Houdini：CSS 领域最令人振奋的革新</a></p></li><li><p><a href="https://tao-wai.gitbooks.io/wai/content/" target="_blank" rel="noopener">网络无障碍建设指南</a></p></li><li><p><a href="https://juejin.im/e/gdd" target="_blank" rel="noopener">2018 Google 开发者大会记录</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/L5i_wzE8HgpiyrbAlFCC_g" target="_blank" rel="noopener">漫画告诉你什么是DDoS攻击？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/DEHla21cI04fRX1tnnB13Q" target="_blank" rel="noopener">超全的 Vue 开源项目合集，签收一下</a></p></li><li><p><a href="https://www.jianshu.com/p/529406a23447" target="_blank" rel="noopener">谈谈我是如何获得知乎的前端源码的</a></p></li><li><p><a href="https://juejin.im/post/5bacbd395188255c8d0fd4b2" target="_blank" rel="noopener">Nginx与前端开发</a></p></li><li><p><a href="https://juejin.im/post/5badfc53f265da0af77527b8" target="_blank" rel="noopener">未来的组件化标准 —— 浅尝Web Components</a></p></li><li><p><a href="https://juejin.im/post/5b7cb5716fb9a01a143fd0f7" target="_blank" rel="noopener">关于VUE项目地图开发中大量点标记绘制一些总结</a></p></li><li><p><a href="https://juejin.im/post/5bac7405f265da0af93b097e" target="_blank" rel="noopener">[译]JavaScript响应式的最佳解释</a></p></li></ul><h4 id="201810"><a href="#201810" class="headerlink" title="201810"></a>201810</h4><ul><li><p><a href="https://juejin.im/post/5bbafd78f265da0ad947e6ba" target="_blank" rel="noopener">如何写一个现代的JavaScript库</a></p></li><li><p><a href="https://juejin.im/post/5bbc1b0c6fb9a05cf230140c" target="_blank" rel="noopener">优秀前端必知的话题：我们应该做些力所能及的优化</a></p></li><li><p><a href="https://juejin.im/post/5bb9aed1e51d451a3f4c3923" target="_blank" rel="noopener">我如何零基础转行成为一个自信的前端</a></p></li><li><p><a href="http://www.html5dw.com/post/4929" target="_blank" rel="noopener">利用视口单位实现适配布局</a></p></li><li><p><a href="https://github.com/Jocs/jocs.github.io/issues/22" target="_blank" rel="noopener">一种自动化生成骨架屏的方案</a></p></li><li><p><a href="https://juejin.im/post/5bd07157f265da0ad221cd19" target="_blank" rel="noopener">使用CSS自定义属性构建骨架屏</a></p></li><li><p><a href="https://juejin.im/post/5b73c71fe51d45666016655a" target="_blank" rel="noopener">前端关于单点登录的知识</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/46284079" target="_blank" rel="noopener">精致化的微前端开发之旅</a></p></li><li><p><a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html" target="_blank" rel="noopener">如何在Vue项目中使用vw实现移动端适配</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/_8vpfui02sW7DFG-1TXnsw" target="_blank" rel="noopener">利用CSS改变图片颜色的100种方法！</a></p></li><li><p><a href="https://juejin.im/post/5bc755b15188255c89015f39" target="_blank" rel="noopener">JavaScript原型与原型链</a></p></li><li><p><a href="https://houxingyi.github.io/2017/10/10/2017-10-10-routes-in-100-line/" target="_blank" rel="noopener">一个100行内的现代js路由</a></p></li><li><p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p></li><li><p><a href="https://www.yuque.com/yuque/blog/1024" target="_blank" rel="noopener">阿里巴巴集团开源软件巡礼</a></p></li><li><p><a href="http://jartto.wang/2018/10/13/nodejs-pdf/" target="_blank" rel="noopener">抓取网页生成 PDF</a></p></li><li><p><a href="https://juejin.im/post/5bd2f19051882526d14975d2" target="_blank" rel="noopener">厌倦了写活动页？快来撸一个页面生成器吧！</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/k6OhMNrpagtTmbhkW-tmZg" target="_blank" rel="noopener">重磅！尤雨溪发布Vue 3.0开发路线</a></p></li><li><p><a href="https://juejin.im/post/5bb719b9f265da0ab915dbdd" target="_blank" rel="noopener">[译] 尤雨溪：Vue 3.0 计划</a></p></li></ul><h4 id="201811"><a href="#201811" class="headerlink" title="201811"></a>201811</h4><ul><li><p><a href="https://segmentfault.com/a/1190000016852780" target="_blank" rel="noopener">前端如何高效的与后端协作开发</a></p></li><li><p><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" target="_blank" rel="noopener">前端异常监控解决方案研究</a></p></li><li><p><a href="https://juejin.im/post/5bd96c5a5188257f96542cbf" target="_blank" rel="noopener">[译]浏览器工作原理探究</a></p></li><li><p><a href="http://www.css88.com/archives/9922" target="_blank" rel="noopener">JavaScript 完全手册（2018版）</a></p></li><li><p><a href="https://hpoenixf.com/posts/25280/" target="_blank" rel="noopener">前端进阶系列-目录</a></p></li><li><p><a href="https://juejin.im/post/5bdfef86e51d453bf8051bf8" target="_blank" rel="noopener">JavaScript 复杂判断的更优雅写法</a></p></li><li><p><a href="https://www.css88.com/archives/10004" target="_blank" rel="noopener">JavaScript 开发者 10 种必备 VS Code 扩展</a></p></li><li><p><a href="https://juejin.im/post/5bbcd7ff5188255c80668028" target="_blank" rel="noopener">几种常见的CSS布局</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/hOKfbgd-nRn2lboXMCiY8w" target="_blank" rel="noopener">前后端均适用的网络知识点大全</a></p></li><li><p><a href="https://juejin.im/post/5bdfb387e51d452c8e0aa902" target="_blank" rel="noopener">年终回顾，为你汇总一份「前端技术清单」</a></p></li><li><p><a href="https://juejin.im/post/5be2dd8fe51d451bb447e0a5" target="_blank" rel="noopener">CSS 来实现多行文字截断</a></p></li><li><p><a href="https://juejin.im/post/5be797456fb9a04a0378bb91" target="_blank" rel="noopener">实现一个可无限折叠的table</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/B5Nl7vee9yWdcd_oxn0bXQ" target="_blank" rel="noopener">抛开 Vue、React、JQuery 这类第三方js，我们该怎么写代码？</a></p></li><li><p><a href="https://juejin.im/post/5bec223f5188250c102116b5" target="_blank" rel="noopener">用100行代码提升10倍的性能</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/d_ORZMYZEglaYpukeSucDg" target="_blank" rel="noopener">2018年JavaScript生态圈调查报告出炉！</a></p></li><li><p><a href="https://juejin.im/post/5bf3c7a551882511a85283f2" target="_blank" rel="noopener">JavaScript 如日中天，2018趋势报告来啦！</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ViVe7HFeVrGeG2xTf-ZMpA" target="_blank" rel="noopener">【职经】从VUE CONF大会我所想到的</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/W36opjFlnXMD0JJUSQbSlg" target="_blank" rel="noopener">Vue.js作者尤雨溪为你分享：Vue 3.0 进展</a></p></li><li><p><a href="https://vue.w3ctech.com" target="_blank" rel="noopener">第二届Vue.js开发者大会</a></p></li></ul><h4 id="201812"><a href="#201812" class="headerlink" title="201812"></a>201812</h4><ul><li><p><a href="https://mp.weixin.qq.com/s/dpLx82wDzpp8mkXOeZPSyg" target="_blank" rel="noopener">2019年如何打造自己的“前端品牌”</a></p></li><li><p><a href="https://juejin.im/post/5bf769e0518825773a2ebfe5" target="_blank" rel="noopener">一道面试题引起的思考</a></p></li><li><p><a href="https://juejin.im/post/5bead1b25188251e1a1f4d34" target="_blank" rel="noopener">【手把手带你撸一个脚手架】系列</a></p></li><li><p><a href="https://juejin.im/post/5c0e34dce51d453595324d1e" target="_blank" rel="noopener">一文读懂H5移动开发调试技巧</a></p></li><li><p><a href="https://juejin.im/post/5c106485e51d450e657571a6" target="_blank" rel="noopener">加快Vue项目的开发速度</a></p></li></ul><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><ul><li><p><a href="https://shenbao.github.io/2017/04/22/justjavac-live/" target="_blank" rel="noopener">前端工程师的入门与进阶</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/N3HV7eEeyyPZYZuTA_DbaQ" target="_blank" rel="noopener">程序员最佳学习方法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/7utZtdK9yc-Krwcofe0csw" target="_blank" rel="noopener">人工智能写前端</a></p></li><li><p><a href="https://www.cnblogs.com/kidney/p/6624521.html" target="_blank" rel="noopener">转行一周年</a></p></li><li><p><a href="https://www.cnblogs.com/kidney/p/8722226.html" target="_blank" rel="noopener">入行两周年</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/dnNxaJTsBZtHkgIlM4RsVA" target="_blank" rel="noopener">JS之父和JSON之父：JavaScript的下一站</a></p></li><li><p><a href="https://juejin.im/post/5adf3778518825672033b6cc" target="_blank" rel="noopener">我们和优秀工程师的差距在哪儿</a></p></li><li><p><a href="https://www.cnblogs.com/Smiled/p/8377188.html" target="_blank" rel="noopener">我所理解的前端</a></p></li><li><p><a href="https://juejin.im/post/5afe3735518825426539afce" target="_blank" rel="noopener">如何阅读大型前端开源项目的源码</a></p></li><li><p><a href="https://juejin.im/post/5ae97bd05188256719521ae0" target="_blank" rel="noopener">如何在疲劳的JS世界中持续学习</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/HaZdhoDlatDIoQbhrf1N0g" target="_blank" rel="noopener">浅谈如何学习JavaScript？</a></p></li><li><p><a href="https://juejin.im/post/5bd9d88ff265da397242c145" target="_blank" rel="noopener">支援一波 《面试数十人有感》</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/FEg9eZqDcHFo-tUmLr2xxg" target="_blank" rel="noopener">克军：如何成为一位优秀的前端工程师？</a></p></li></ul><h2 id="Vue-组件库开发杂谈"><a href="#Vue-组件库开发杂谈" class="headerlink" title="Vue 组件库开发杂谈"></a>Vue 组件库开发杂谈</h2><ul><li><p><a href="https://juejin.im/post/598965bd5188256da941872c" target="_blank" rel="noopener">Vue 组件库实践和设计</a></p></li><li><p><a href="http://jdc.jd.com/archives/212167" target="_blank" rel="noopener">漫谈Vue组件库开发</a></p></li><li><p><a href="http://jdc.jd.com/archives/212600" target="_blank" rel="noopener">再谈Vue组件库开发</a></p></li><li><p><a href="http://blog.johnsenzhou.com/2018/%E5%85%AC%E5%8F%B8vue%E7%BB%84%E4%BB%B6%E5%BA%93%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97" target="_blank" rel="noopener">公司vue组件库开发心得</a></p></li><li><p><a href="https://juejin.im/post/5b7f81ece51d4538c210a0fc" target="_blank" rel="noopener">我写了一个面向源码阅读者的 UI 框架（基于 Vue）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;技术文章&quot;&gt;&lt;a href=&quot;#技术文章&quot; class=&quot;headerlink&quot; title=&quot;技术文章&quot;&gt;&lt;/a&gt;技术文章&lt;/h2&gt;&lt;h4 id=&quot;更早之前&quot;&gt;&lt;a href=&quot;#更早之前&quot; class=&quot;headerlink&quot; title=&quot;更早之前&quot;&gt;&lt;/a&gt;更早之前&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://eux.baidu.com/blog/fe/%E5%88%A9%E7%94%A8-javascript-%E5%AE%9E%E7%8E%B0%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;利用 javascript 实现富文本编辑器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5965943ff265da6c30653879&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JS正则表达式完整教程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a6fce10f265da3e261c3c71&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从0.1+0.2=0.30000000000000004再看JS中的Number类型&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://qiutc.me/post/cross-domain-collections.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端跨域的整理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="总结归纳" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    
    
      <category term="总结归纳" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>H5页面生成项目集合</title>
    <link href="http://yoursite.com/2018/12/27/%E6%94%B6%E9%9B%86%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2018/12/27/收集的项目资源/</id>
    <published>2018-12-27T07:20:17.983Z</published>
    <updated>2018-12-27T07:23:12.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="H5页面生成项目集合"><a href="#H5页面生成项目集合" class="headerlink" title="H5页面生成项目集合"></a>H5页面生成项目集合</h2><ul><li><p><a href="https://github.com/qiuyaofan/iShow" target="_blank" rel="noopener">iShow</a></p></li><li><p><a href="https://github.com/zhengguorong/h5maker" target="_blank" rel="noopener">h5maker</a></p></li><li><p><a href="https://github.com/jaweii/Vue-Layout" target="_blank" rel="noopener">基于UI组件的Vue可视化布局工具</a></p></li><li><p><a href="https://github.com/answershuto/H5" target="_blank" rel="noopener">可视化编辑手机H5页面的单页应用WebApp</a></p></li><li><p><a href="https://github.com/bison1994/lazycoder" target="_blank" rel="noopener">lazycoder</a></p></li><li><p><a href="https://h5.bce.baidu.com/" target="_blank" rel="noopener">百度H5</a></p></li><li><p><a href="https://github.com/h5ds/h5ds" target="_blank" rel="noopener">h5ds: 一款基于WEB的 H5制作工具</a></p></li></ul><a id="more"></a><h2 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h2><ul><li><p><a href="https://juejin.im/post/5b3027cce51d4558c65216a9" target="_blank" rel="noopener">mpvue美团外卖小程序</a>(项目地址: <a href="https://github.com/WsmDyj/mpvue" target="_blank" rel="noopener">https://github.com/WsmDyj/mpvue</a>)</p></li><li><p><a href="https://juejin.im/post/5b15ce94f265da6e29010554" target="_blank" rel="noopener">滴滴打车微信小程序</a>(项目地址: <a href="https://github.com/WsmDyj/didi" target="_blank" rel="noopener">https://github.com/WsmDyj/didi</a>)</p></li><li><p><a href="https://juejin.im/post/5b39bbcc5188252ce018c745" target="_blank" rel="noopener">天气应用微信小程序</a>(项目地址: <a href="https://github.com/myvin/quietweather" target="_blank" rel="noopener">https://github.com/myvin/quietweather</a>)</p></li><li><p><a href="https://juejin.im/post/5b1cec3951882513e905998e" target="_blank" rel="noopener">仿小米商城小程序</a>(项目地址: <a href="https://github.com/JoeWrights/wxapp-mi-mall" target="_blank" rel="noopener">https://github.com/JoeWrights/wxapp-mi-mall</a>)</p></li><li><p><a href="https://juejin.im/post/5b1a104a5188257d9f24c7f9" target="_blank" rel="noopener">仿改青桔单车小程序</a>(项目地址: <a href="https://github.com/hx-dl/bicycle" target="_blank" rel="noopener">https://github.com/hx-dl/bicycle</a>)</p></li></ul><h2 id="Vue-项目"><a href="#Vue-项目" class="headerlink" title="Vue 项目"></a>Vue 项目</h2><ul><li><p><a href="https://juejin.im/post/5aca46e2f265da238c3af4ca" target="_blank" rel="noopener">仿美团外卖的全栈项目</a>(项目地址: <a href="https://github.com/zwStar/vue-meituan" target="_blank" rel="noopener">https://github.com/zwStar/vue-meituan</a>)</p></li><li><p><a href="https://github.com/cccyb/vue-zhihu-daily" target="_blank" rel="noopener">vue-zhihu-daily</a></p></li><li><p><a href="https://github.com/IFmiss/vue-music" target="_blank" rel="noopener">网易云音乐播放器</a></p></li><li><p><a href="https://github.com/beautifulBoys/vue-XiaoMi-Shop" target="_blank" rel="noopener">高仿小米商城（手机版）的Vue项目</a></p></li><li><p><a href="https://github.com/iview/iview-admin" target="_blank" rel="noopener">iview-admin</a></p></li><li><p><a href="https://github.com/PowerDos/Mall-Vue" target="_blank" rel="noopener">基于Vue+Vuex+iView的电子商城网站</a></p></li></ul><h3 id="vue-ui-库-作为项目参考"><a href="#vue-ui-库-作为项目参考" class="headerlink" title="vue ui 库(作为项目参考)"></a>vue ui 库(作为项目参考)</h3><ul><li><p><a href="https://github.com/luojilab/radon-ui" target="_blank" rel="noopener">一个用于快速开发产品的简洁、优雅、高效的 Vue 组件库</a></p></li><li><p><a href="https://github.com/MeituPhone/coo-vue" target="_blank" rel="noopener">一些常用的vue响应式组件</a></p></li><li><p><a href="https://github.com/monw3c/xmui" target="_blank" rel="noopener">xmui</a></p></li><li><p><a href="https://github.com/VV-UI/VV-UI" target="_blank" rel="noopener">VV-UI</a></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p><a href="https://github.com/mengdu/vue-component-devtool" target="_blank" rel="noopener">基于 webpack 打造的 Vue 组件开发工具</a></p></li><li><p><a href="https://github.com/fengyuanchen/cropper" target="_blank" rel="noopener">cropper 图片裁剪插件</a></p></li><li><p><a href="https://github.com/xluos/demo" target="_blank" rel="noopener">平时学习练习的一些小Demo的仓库</a></p></li><li><p><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">The HTML Presentation Framework</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;H5页面生成项目集合&quot;&gt;&lt;a href=&quot;#H5页面生成项目集合&quot; class=&quot;headerlink&quot; title=&quot;H5页面生成项目集合&quot;&gt;&lt;/a&gt;H5页面生成项目集合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/qiuyaofan/iShow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iShow&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zhengguorong/h5maker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h5maker&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jaweii/Vue-Layout&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于UI组件的Vue可视化布局工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/answershuto/H5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可视化编辑手机H5页面的单页应用WebApp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/bison1994/lazycoder&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lazycoder&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://h5.bce.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度H5&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/h5ds/h5ds&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h5ds: 一款基于WEB的 H5制作工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端早读课</title>
    <link href="http://yoursite.com/2018/12/27/%E5%89%8D%E7%AB%AF%E6%97%A9%E8%AF%BB%E8%AF%BE/"/>
    <id>http://yoursite.com/2018/12/27/前端早读课/</id>
    <published>2018-12-27T07:20:17.977Z</published>
    <updated>2018-12-27T07:24:14.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公众号-前端早读课推文列表"><a href="#公众号-前端早读课推文列表" class="headerlink" title="公众号-前端早读课推文列表"></a>公众号-前端早读课推文列表</h2><p>每两周更新</p><p>部分参考： <a href="https://github.com/if2er/FeZaoDuKe-Collection" target="_blank" rel="noopener">https://github.com/if2er/FeZaoDuKe-Collection</a></p><ul><li><p><a href="https://mp.weixin.qq.com/s/_z_MRVb-O-Xfj-9Qael7wA" target="_blank" rel="noopener">【第1476期】如何提升设计到开发的协作效率</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/V7HJJUpd40yd0y03aMyJVw" target="_blank" rel="noopener">【第1475期】企鹅辅导课程详情页毫秒开的秘密 - PWA 直出</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/qBD90RdofvYDNX2sSJWgNA" target="_blank" rel="noopener">【第1474期】HTTP/3 要点</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/7qBU5gGq5Tv2QEzuHDF7gg" target="_blank" rel="noopener">【第1473期】用代码做设计</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/iHDium37WsmWxbKwhOVsgA" target="_blank" rel="noopener">【第1472期】我们为什么要写 super(props)?</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/EnS22WGKiXnTCdFnqrVahA" target="_blank" rel="noopener">【第1471期】AST抽象语法树——最基础的javascript重点知识</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/SQfIImIBKfSvDjITz2h_Mw" target="_blank" rel="noopener">【第1470期】为什么前端工程师需要关注设计</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/xXPAkfQkmkWWK_2HCyE7Mg" target="_blank" rel="noopener">【第1469期】篡改NPM包盗取比特币始末</a></p><a id="more"></a></li><li><p><a href="https://mp.weixin.qq.com/s/NRZQI-Md0dqNAGY96qsn-A" target="_blank" rel="noopener">【第1468期】前端与编译原理——用JS写一个JS解释器</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/mH2PNPLvmeaCyiY6ikGlLA" target="_blank" rel="noopener">【第1467期】使用 okam 小程序开发框架快速开发百度智能小程序</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/qmwf1qqIcROd6h-LWm2gQQ" target="_blank" rel="noopener">【第1466期】通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/sVcGRUZqILCVgfhzRyODTg" target="_blank" rel="noopener">【第1465期】内存管理速成教程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/AURDiWwspdfRExopNf4YLQ" target="_blank" rel="noopener">【第1464期】babel7使用手册</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/zrWyOuSBQMfsVD2-0njXOA" target="_blank" rel="noopener">【第1463期】谨慎处理 Service Worker 的更新</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/2miV4y8tK5Cx19QenzbLgQ" target="_blank" rel="noopener">【第1462期】赶上 ECMAScript 潮流：用现代 JavaScript 编程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0-k1xZr8-nPCakN-jnfRnQ" target="_blank" rel="noopener">【第1461期】平庸前端码农之蜕变 — AST</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0zK6mT0K0gmM6GuvRzYWLA" target="_blank" rel="noopener">【第1460期】JavaScript 基础：Babel 转译 class 过程窥探</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/-yNglTnJFbaDDFbq9usleA" target="_blank" rel="noopener">【第1459期】await VS return VS return await</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/n9Q-b65Zya5bxlM6F3v-tQ" target="_blank" rel="noopener">【第1458期】ElementUI的构建流程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/gwjV0NC8JbF-QfwuQ-ayjw" target="_blank" rel="noopener">【第1457期】CSS 与网络性能</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/XNNGNLAhEAQqRVTS64BQlQ" target="_blank" rel="noopener">【第1456期】更快的 async 函数和 promises</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/sxbs2W8IkURo-agamUDivw" target="_blank" rel="noopener">【第1455期】新一代页面生命周期API：来自Chrome官方博客的介绍</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Q2kdX5zIkfIlUURQmwKDjw" target="_blank" rel="noopener">【第1454期】JS箭头函数三连问：为何用、怎么用、何时用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/h9hLC_o3hOmnpEOaXryg-A" target="_blank" rel="noopener">【第1453期】理解JavaScript的柯里化</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/uc6ZQx0KRZfqJoT_VzUyFg" target="_blank" rel="noopener">【第1452期】见微知著，Google Photos Web UI 完善之旅</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/TfEyuhyYMoL7o8RZM_brYg" target="_blank" rel="noopener">【第1451期】在 JavaScript 和 WebAssembly 之间调用执行速度终于快了</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rcu6qswqti8sg3fgqCAVSw" target="_blank" rel="noopener">【第1450期】交互细节：页面链接打开方式探讨</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/I-yzvECT9GX3yfzlfY09jg" target="_blank" rel="noopener">【第1449期】WebAssembly 后 MVP 时代的未来：卡通技能树</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/xLZnr1_M-C7X3geBBiNwXQ" target="_blank" rel="noopener">【第1448期】深入理解 React 高阶组件</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/wcy72YVvq12RiNTC2Lt_vA" target="_blank" rel="noopener">【第1447期】如何通过 HSB 颜色模式构建夜间模式</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ugowewKOS2akx5uuGOzclQ" target="_blank" rel="noopener">【第1446期】精致化的微前端开发之旅</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/fxqWZnkBEv_T0ULzEZa4yQ" target="_blank" rel="noopener">【第1445期】Vue: scoped 样式与 CSS Module 对比</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/KRFYclPnkkdXbkJCSTohCw" target="_blank" rel="noopener">【第1444期】30分钟精通React今年最劲爆的新特性——React Hooks</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BXC6tZyY6fsi8l8dJ40nug" target="_blank" rel="noopener">【第1443期】React 中同构（SSR）原理脉络梳理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/K5HT_Balcsq7B0IT5jtDBw" target="_blank" rel="noopener">【第1442期】 如何写出一手好的小程序之多端架构篇</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/uxPvSCKFhQLx0Y5kuNa71g" target="_blank" rel="noopener">【第1441期】 Lighthouse的使用与Google的移动端最佳实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/G2z6BIf3yqAeYEocPWOdtQ" target="_blank" rel="noopener">【第1440期】你所不知道的 CSS 阴影技巧与细节</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/g1OAjUofxPfJKRdIjXJu8A" target="_blank" rel="noopener">【第1439期】React 项目结构和组件命名之道</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/1v6MqN97xV0zyCph7pl5IA" target="_blank" rel="noopener">【第1438期】如何让你的网页“看起来”展现地更快 —— 骨架屏二三事</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/iDbDyWeSDgShqR_nQ1po_g" target="_blank" rel="noopener">【第1437期】深拷贝的终极探索</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Qq3wQPlQVmNV4VObMdqcSw" target="_blank" rel="noopener">【第1436期】利用交叉观察器解锁懒加载新姿势</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T2Zdmhknyo14EPkANSaU8g" target="_blank" rel="noopener">【第1435期】国际化 - 通用 LTR/RTL 布局解决方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/yNHTkcJ6vIxfFX4YpozWgA" target="_blank" rel="noopener">【第1434期】渔人和Rxjs的故事</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/zZv61y9nVnDHiOKDDTwOuw" target="_blank" rel="noopener">【第1433期】CSS3动画实战之多关键帧实现无限循环动效的时间间隔</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/n5nUGdOO-JxkPsM7G7UCAQ" target="_blank" rel="noopener">【第1432期】megalo – 网易考拉小程序解决方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cb8VJOmAB1Yrv-ct4jJ3JQ" target="_blank" rel="noopener">【第1431期】图解浏览器的基本工作原理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/64a9ODiT9uutJiYqxdAnJw" target="_blank" rel="noopener">【第1430期】以面试官的角度来看 React 工作面试</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Y9cs7pyQBI5NUyxPujZFWQ" target="_blank" rel="noopener">【第1429期】详解JavaScript中的this</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/uGEEdSN1ehdn3wxNUiEYaQ" target="_blank" rel="noopener">【第1428期】React v16.7 “Hooks” - What to Expect</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/1Znvnr3uoVsW9QoqSmJ34Q" target="_blank" rel="noopener">【第1427期】构建大型 Redux 应用的五个建议</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/N_4av_FOE4KBQiHXRI6_Tw" target="_blank" rel="noopener">【第1426期】代码优化策略 — Idle Until Urgent</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/q6IEa-_7OZ0m58sg7qkSpQ" target="_blank" rel="noopener">【第1425期】精读《12 个评估 JS 库你需要关心的事》</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/L6JHBlKsTpkTMREZWUWQ8Q" target="_blank" rel="noopener">【第1424期】你听说过原生 HTML 组件吗？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/SPoxin9LYJ4Bp0goliEaUw" target="_blank" rel="noopener">【第1423期】数据劫持 OR 数据代理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/zTeFezA6CEVhseBvoniuzA" target="_blank" rel="noopener">【第1422期】成为高级工程师后，职业生涯的下一步是什么</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/WEMAFqWneAmmsjwYWt_rTQ" target="_blank" rel="noopener">【第1421期】2018年如何写一个现代的JavaScript库</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/GktsHoN3q12nz8c-QlfqgQ" target="_blank" rel="noopener">【第1420期】JavaScript 响应式与 Proxy</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/SbQLHbBZ8gM9c6uvd7eAbw" target="_blank" rel="noopener">【第1419期】JavaScript 计时器之旅</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/qeo3y8l3tGgVeA4oJbWc_g" target="_blank" rel="noopener">【第1418期】JavaScript 响应式原理的最佳解释</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/WXfTjb3w51yvM3U50Y_AEg" target="_blank" rel="noopener">【第1417期】浅析 React / Vue 跨端渲染原理与实现</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/dtHn6WU-Q9kkArWD8YfvCQ" target="_blank" rel="noopener">【第1416期】CSS实现水平垂直居中的1010种方式</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/V4fTknn11pUENn0MEMzObA" target="_blank" rel="noopener">【第1415期】五个小技巧让你写出更好的 JavaScript 条件语句</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/TzrWOgMWbbw5N6Bf8XHQ2g" target="_blank" rel="noopener">【第1414期】缓存 React 事件监听器来提高性能</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/-6whTMkI_cIAKFXiXWPTog" target="_blank" rel="noopener">【第1413期】 我如何零基础转行成为一个自信的前端</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/hbwU91bfPLknpZfIBEWeNQ" target="_blank" rel="noopener">【第1412期】React Native vs. Cordova、PhoneGap、Ionic，等等</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OMvNKq1P5cDCzzqpmGpOjw" target="_blank" rel="noopener">【第1411期】Airbnb 爱彼迎房源详情页中的 React 性能优化</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/WAeDvcX7X7t0zbCk4PoCqA" target="_blank" rel="noopener">【第1410期】尤雨溪：Vue 3.0 计划</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BO-ENlbvah2H-__QXwUvYw" target="_blank" rel="noopener">【第1409期】 React之深入理解 Props 和 State</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/igkif-J_BHd1q5mZ7TewCw" target="_blank" rel="noopener">【第1408期】浅谈 Vue 中 computed 实现原理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/JPQvhLMpqQIl-GhWIxNtsA" target="_blank" rel="noopener">【第1407期】盘点 React 16.0 ~ 16.5 主要更新及其应用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Z3XLm4hPXoC8PcW1R78D8w" target="_blank" rel="noopener">【第1406期】携程国际BU酒店团队的大前端之路</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/r9hJmsK9oprn5f1CbhAHNQ" target="_blank" rel="noopener">【第1405期】浏览器的 Event Loop</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/wukb02PaZfRXzhqHzfGMBQ" target="_blank" rel="noopener">【第1404期】使用小程序做交互的技巧</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cigjK2kLJzgRdRy1VwGhfQ" target="_blank" rel="noopener">【第1403期】如何优雅地链式取值</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/JoWELCugqzLITDIDVX8G4w" target="_blank" rel="noopener">【第1402期】云开发初探 —— 更简便的小程序开发模式</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/HQ3CKcJGHUf4BioqHalCqA" target="_blank" rel="noopener">【第1401期】React Fiber 架构学习</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UdLvAMDHUaBL9mIAZXqzQQ" target="_blank" rel="noopener">【第1400期】小程序的全栈开发新时代</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/2IjsJZY78FQcOdTI5JC7ow" target="_blank" rel="noopener">【第1399期】美菜无线前端架构模型2018</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cUqkG3NETmJbglDXfSf0tg" target="_blank" rel="noopener">【第1398期】一文读懂前端缓存</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ZDArcoMYVM2fHqk8CuiMig" target="_blank" rel="noopener">【第1397期】如何在 JavaScript 中更好地使用数组</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/GEKkesqFs86_nSWcem2tJg" target="_blank" rel="noopener">【第1396期】immer.js 简介及源码简析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/KZNoswZrMqRMc6-ibeIN_A" target="_blank" rel="noopener">【第1395期】深入 V8 引擎：“小整数”到底有多小？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/pWpqgvy7Je79IiNWx_oMzQ" target="_blank" rel="noopener">【第1394期】JavaScript 2018 中即将迎来的新功能</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/XwGZvJ5m5rErf9EOmWwmuQ" target="_blank" rel="noopener">【第1393期】小程序多业务线融合【完整分包业务接入】</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/aM-SkTsQrgruuf5wy3xVmQ" target="_blank" rel="noopener">【第1392期】React从渲染原理到性能优化（二）– 更新渲染</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/RoGsu9Tyq5aKdYvTS7zwIA" target="_blank" rel="noopener">【第1391期】前端数据扁平化与持久化</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/GL67ld37lPg4H3L_6nU0fg" target="_blank" rel="noopener">【第1390期】React Native: 回顾 Udacity 移动工程团队的使用历程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/LUNudI_3UpR_5kS69OlIFg" target="_blank" rel="noopener">【第1389期】一起探讨 JavaScript 的对象</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/IYxMkYll1OJ104Rzj_wDMQ" target="_blank" rel="noopener">【第1388期】snabbdom 源码阅读分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/w1dg_V5nVbKbq_TfN933sw" target="_blank" rel="noopener">【第1387期】带你了解什么是工程师和工程师的影响力</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/izjTmtTk0EV4axs18srOEg" target="_blank" rel="noopener">【第1386期】React从渲染原理到性能优化（一）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/GSfHImANxbeZ8fw9hidJsg" target="_blank" rel="noopener">【第1385期】Vue高版本中一些新特性的使用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/7x8_CibR0JDb_plSCGTJoA" target="_blank" rel="noopener">【第1384期】Cat Chen谈前端职业生涯重要的几个阶段</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/o5MJHozQqCcwUl4yVgUGPA" target="_blank" rel="noopener">【第1383期】 微信小程序架构原理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/RByST3DbUTjJIz9AnyFZ8A" target="_blank" rel="noopener">【第1382期】悄悄掀起 WebAssembly 的神秘面纱</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9Qjoqs_jitwZE_KbfEOucA" target="_blank" rel="noopener">【第1381期】前端插拔式 SPA 应用架构实现方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/HVmDVD7tDEsKQunCw86YEg" target="_blank" rel="noopener">【第1380期】如何像程序员般思考 —— 蕴含在问题解决中的经验</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T0e-Zu-SPK0g_ng8Or-APg" target="_blank" rel="noopener">【第1379期】鸽子传信解释 HTTPS</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/qetiJo47IyssYWAr455xHQ" target="_blank" rel="noopener">【第1378期】 一口(很长的)气了解 Babel</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/wmra5Ms8RYuYmA8PIbkrWw" target="_blank" rel="noopener">【第1377期】为什么我们应该关注下 PWA?</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/8mk7fo2PIo8JXIaZWtL7aQ" target="_blank" rel="noopener">【第1376期】CSS自定义属性</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9VB3_M04qegMw8_mA7qYgw" target="_blank" rel="noopener">【第1375期】JavaScript 引擎基础：原型优化</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Y21SEjIwDEGgGpZ1mrPHnQ" target="_blank" rel="noopener">【第1374期】CSS小发明 :in-viewport</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ilkmqnwVvPLjiVfEyNadHg" target="_blank" rel="noopener">【第1373期】无单位数字和行高</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/CvLXXDV_0J-rF-85AWjgsw" target="_blank" rel="noopener">【第1372期】 CSS垂直居中技巧，我只会23个，你会几个？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/4yXWhBuBqVRoQB3krVgNpA" target="_blank" rel="noopener">【第1371期】Node.js 前端开发指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/e7KSy2uedXchGwNDpbGHOw" target="_blank" rel="noopener">【第1370期】 验证码前端性能分析及优化实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/y43K5OL_9zdGDPd0yvHD7A" target="_blank" rel="noopener">【第1369期】简单聊聊 GZIP 的压缩原理与日常应用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ZLeTRaEP4zrjnZRvk5EESA" target="_blank" rel="noopener">【第1368期】视口相关单位的应用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9kiznx6FkqtStaAFgKATIw" target="_blank" rel="noopener">【第1367期】原来浏览器原生支持JS Base64编码解码</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/mnjbc5eeGtwTxdrm73rBrw" target="_blank" rel="noopener">【第1366期】如何精确统计页面停留时长</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/tCLvRad-WrnFKJiStU7BKw" target="_blank" rel="noopener">【第1365期】漫谈前端性能，突破React应用瓶颈</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Ue0kNOMQS7mH-2-9BhYk8Q" target="_blank" rel="noopener">【第1364期】Webpack之treeShaking</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/sKQ7eU95NOyBTn-2ZXha4w" target="_blank" rel="noopener">【第1363期】 用JS写一个同Excel表现的智能填充算法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/t8HH4BgWNZ10gbFpAiv_1A" target="_blank" rel="noopener">【第1362期】微信小程序30分钟从陌生到熟悉（上）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/gy2xrKy9QJJtRiOy_6i6iA" target="_blank" rel="noopener">【第1362期】微信小程序30分钟从陌生到熟悉（下）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/vaCoNS3UsSeiSpYlbiUtFg" target="_blank" rel="noopener">【第1361期】如何更愉快地使用rem</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/dKYlKuD2wrMAK-bRBHHASg" target="_blank" rel="noopener">【第1360期】初学者应该了解的数据结构： Tree</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/8XzNE0VfkgbqVg9_Ro4GBQ" target="_blank" rel="noopener">【第1359期】JavaScript核心概念：类型转换</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cFeo_zEtva893Q9O-i2K4w" target="_blank" rel="noopener">【第1358期】如何直观的在JavaScript中管理状态</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/14Eq-8lAyVUhdFMvpD0wdw" target="_blank" rel="noopener">【第1357期】狙杀页面卡顿 —— PERFORMANCE 指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Yczyla8Key-oJ3QqpAt0BA" target="_blank" rel="noopener">【第1356期】如何更愉快地使用em</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cnqrhVVW7mjJaUhSLJyaoA" target="_blank" rel="noopener">【第1355期】组件、Prop 和 State</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/M7m-eAXtssct2B7nh19S0g" target="_blank" rel="noopener">【第1354期】精读 The Cost of JavaScript</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/mGjtX1frBiHQoCGVNpDE9g" target="_blank" rel="noopener">【第1353期】用户体验法则</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/QEwb3hL0k95bOC1OPfENwQ" target="_blank" rel="noopener">【第1352期】map和reduce，处理数据结构的利器</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/n3sBxtE66MF_SWj9MvAikw" target="_blank" rel="noopener">【第1351期】JavaScript 中的私有变量</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/MYDiXVd5rgSPJvKoaFEiBg" target="_blank" rel="noopener">【第1350期】2018年值得关注的10大JavaScript动画库</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0_0nRVhsnQGU9wgb2Dap-Q" target="_blank" rel="noopener">【第1349期】谈谈JS数组中的indexOf方法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/TntqjAaUEwdnC7WJvjQlXg" target="_blank" rel="noopener">【第1348期】理解伪元素:before和:after</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/VMSwJIuk1BbcZerVopUWhQ" target="_blank" rel="noopener">【第1347期】15分钟成为 GIT 专家</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/leniuG9xBpad3bVTXq-23w" target="_blank" rel="noopener">【第1346期】如何更好的编写CSS</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/nim-KSqO3n2d2qwbTHKBJA" target="_blank" rel="noopener">【第1345期】解析 GraphQL 的查询语法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/WUcO54P31GHYZYVVpBWtSw" target="_blank" rel="noopener">【第1344期】如何设计提示文字</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/sU8PPwFhM0IcVBB2GJF8Kw" target="_blank" rel="noopener">【第1343期】GraphQL 在微服务架构中的实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/43rmSasjJD-mCnOYEN_v1A" target="_blank" rel="noopener">【第1342期】图解 React Native</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/WRAv9Tjw__3KUWt4glg9ng" target="_blank" rel="noopener">【第1341期】React组件模式</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/6RRK4Gb__cvCwg6CjykFrQ" target="_blank" rel="noopener">【第1340期】希望是最浅显易懂的RxJS教程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ggVkc9iWLgeLGS1ZiJb8Dw" target="_blank" rel="noopener">【第1339期】如何不择手段提升scroll事件的性能</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Yjci-hw_UC7E6ghESp8c4g" target="_blank" rel="noopener">【第1338期】利用StoryBook开发UI组件管理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/qeWkKsxH8eyqKlCZDeGUwA" target="_blank" rel="noopener">【第1337期】JavaScript 是如何工作的：用 MutationObserver 追踪 DOM 的变化</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/pHH9OToiYC90M18rS-fBFg" target="_blank" rel="noopener">【第1336期】Airbnb 中的 React Native：技术部分</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/qmyn6mGrO6hRKuvKUSF8lA" target="_blank" rel="noopener">【第1335期】这个控件叫：Skeleton Screen/加载占位图</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0ehjOhqkD3VHevVGU5-XOg" target="_blank" rel="noopener">【第1334期】组件开发的单元素模式</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/KQYah-AskGTa_5zyNLm3Jw" target="_blank" rel="noopener">【第1333期】图解 React</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/mRMOPx6ykghrbkrgkKVQiw" target="_blank" rel="noopener">【第1332期】移动端跨平台开发的深度解析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ttcWBmULVoHF2dBtyYDnUA" target="_blank" rel="noopener">【第1331期】初学者应该如何开启自己的编程生涯？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/gl1LR9Ps4Dr86uIBWXChAw" target="_blank" rel="noopener">【第1330期】洞察 video 超能力系列——玩转 mp4</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PlOdvq3Xe4Heo8Xxf2gEfg" target="_blank" rel="noopener">【第1329期】从设计师的角度看 Redux</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/7Ze6P77X4iFCUEz9LQHxrQ" target="_blank" rel="noopener">【第1328期】八幅漫画理解使用JSON Web Token设计单点登录系统</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/hdzdjx6ek2_pAVL10f3q_Q" target="_blank" rel="noopener">【第1327期】如何找到一份好的前端开发工作</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/q-4NzWJLimPSK9oaXOWUlA" target="_blank" rel="noopener">【第1326期】WebView缓存原理分析和应用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/TFm7SALJDnyXDt_QMxx0wQ" target="_blank" rel="noopener">【第1325期】以开发的视角做设计</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/hI2Z3NVL6Ey0TA8DwWGIsQ" target="_blank" rel="noopener">【第1324期】如何像个程序员一样思考</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/pGP5Oohcban0P1GAzPlAgg" target="_blank" rel="noopener">【第1323期】揭开JS无埋点技术的神秘面纱</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/pzAK6Rxe8iHnWimQw2W5tg" target="_blank" rel="noopener">【第1322期】Vue CLI 3 配置中 Modern mode 是什么</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/wAF7YHtYNsSbQOzI5PZeFw" target="_blank" rel="noopener">【第1321期】SVG滤镜对图片调色</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/i_Zxaie1xMALymQ-1Jqz_Q" target="_blank" rel="noopener">【第1320期】你不知道的前端SDK开发技巧</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/4p0rJhuCYavgif5JAqiNKA" target="_blank" rel="noopener">【第1319期】deno深入揭秘及未来展望</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/6nrYnPgiOMbheGPNUlbOVA" target="_blank" rel="noopener">【第1318期】深入浅出 JavaScript 关键词 – this</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/TbJqGUgol26lGCDjeGvY3g" target="_blank" rel="noopener">【第1317期】在 web 上使用 JavaScript 模块</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/YiKRY_LDURY0uONtEhkUfg" target="_blank" rel="noopener">【第1316期】大前端时代前端监控的最佳实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/etnLUbok8BUZBAMr3bKWGg" target="_blank" rel="noopener">【第1315期】GraphQL 基于 SPA 架构的工程实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/AWzJKF1bnPe1WFI3ti5cPA" target="_blank" rel="noopener">【第1314期】JavaScript 引擎基础：Shapes 和 Inline Caches</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9yTZ8Grt5wGXix7WFWrnhw" target="_blank" rel="noopener">【第1313期】一个Vue页面的内存泄露分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/F-GJjNwlCfQE0rJ_QySFsg" target="_blank" rel="noopener">【第1312期】Node.js开发之父：十个Node.js的设计错误以及其终极解决办法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/c_QTdLu6vsYcIiuPRZyjyA" target="_blank" rel="noopener">【第1311期】浅析前端安全之 XSS</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/DrTb9KSxTE7jt5kY16GZwQ" target="_blank" rel="noopener">【第1310期】ES2018（ES9）的新特性</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OYBmHibwPI_ODJ3UkJj4WQ" target="_blank" rel="noopener">【第1309期】nuxt缓存实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/a0SeJx7mzJA5nQiOQl3ivw" target="_blank" rel="noopener">【第1308期】语义化版本控制规范（SemVer）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/-rKyKRy7gMYTWmCLKRhNmQ" target="_blank" rel="noopener">【第1307期】理解TCP/IP三次握手与四次挥手的正确姿势</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/kjrMnj9A404RjYtynBqxLw" target="_blank" rel="noopener">【第1306期】GraphQL 聚合层解放前后端</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Ya8qH__XYsQAAzuNzzsyfQ" target="_blank" rel="noopener">【第1305期】Hubble 见证 Vue 与 React 突破 10 万 GitHub Stars!</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/HLg3SrzJYBp9PcXnmU3XZQ" target="_blank" rel="noopener">【第1304期】聊一聊Redux的前身Flux</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ScQdoysvLq8Pbc04LJII9w" target="_blank" rel="noopener">【第1303期】webpack4初探</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Or-aacPjEYfXnwg3g2VfEg" target="_blank" rel="noopener">【第1302期】基于 MobX 构建视图框架无关的数据层-与 Vue 的结合</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/HPlnsBYyrulFczGeNxVyCw" target="_blank" rel="noopener">【第1301期】如何阅读大型前端开源项目的源码</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/V7vJhQx4pyxX22eLbGHkGw" target="_blank" rel="noopener">【第1300期】多端统一开发框架 - Taro</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Ui5TKoBWteDORx5CEswx5w" target="_blank" rel="noopener">【第1299期】浅谈混合应用的演进</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/kl107B5j6VDIkNr_IdHu-Q" target="_blank" rel="noopener">【第1298期】宋小菜生鲜 B2B 的前端团队搭建</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/GanPiEkJFJqURZ7HNUMXSQ" target="_blank" rel="noopener">【第1297期】HTTPS 的故事</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/fLGaVR-F8hFtZmHMFaNB4A" target="_blank" rel="noopener">【第1296期】由一个bug找到JS挖矿代码</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/dw5D6wpOKJTlc_mNKjAPdQ" target="_blank" rel="noopener">【第1295期】浅谈 instanceof 和 typeof 的实现原理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/juB6QotmECtHHh2e3vRgoQ" target="_blank" rel="noopener">【第1294期】JS Linter 进化史</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/8NtfuoVFBp1LszXjVMB_Zw" target="_blank" rel="noopener">【第1293期】浏览器之美，你知道多少？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/AWSXyRihRHJb_CYXSOUnpw" target="_blank" rel="noopener">【第1292期】GitHub 的用法与礼仪</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/sM1xf50g2Gg7n2t8GQh6pw" target="_blank" rel="noopener">【第1291期】Puppeteer入门简介</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/nIWgfVqsDmmaSGQ-cz__sQ" target="_blank" rel="noopener">【第1290期】 一个安卓设备管理操作平台-STF</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/SyUk9rGh-wSGP8pHr9FlJg" target="_blank" rel="noopener">【第1289期】W3C工作备忘 – 布局</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/_5i6ec3WvyXLLNEPTfd4qg" target="_blank" rel="noopener">【第1287期】深入浅出 SVG</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/tG56t5pd1Kw_O2NBXGAk6Q" target="_blank" rel="noopener">【第1286期】滑向未来：现代 JavaScript 与 CSS 滚动实现指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/XaiFrB4h3Y-upEoFZo2Jdg" target="_blank" rel="noopener">【第1285期】我知道的HTTP请求</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UYHT-EwbUOg1mGCI6bTgpA" target="_blank" rel="noopener">【第1284期】大学没学过数学也要理解 CSS3 transform 中的 matrix</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/aKwEF0ES1ldH5e0jgvh6qA" target="_blank" rel="noopener">【第1283期】从0开始发布一个无依赖、高质量的npm</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/pcUbnYyVHSebOelDlHA27g" target="_blank" rel="noopener">【第1282期】页面可视化搭建工具前生今世</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/KxJttCVuCoIrm9RAjRBrdg" target="_blank" rel="noopener">【第1281期】React 16 加载性能优化指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/dZcewK7dIAUbYBLEwCFcmg" target="_blank" rel="noopener">【第1280期】如何利用 Chrome 浏览器实现滚动截屏</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/xplXqYsHC4aRzAR45tSdkA" target="_blank" rel="noopener">【第1279期】无尽滚动的复杂度</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/gVLXJO0IXol4q_ademXMWg" target="_blank" rel="noopener">【第1278期】上课啦！了解下 DDoS攻击方式</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/iVM3nhb0p7FdvsfYMrk7cQ" target="_blank" rel="noopener">【第1277期】Google I/O 2018 —— Web 系列参会笔记</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Q7YfodO8l4FyawH7dQuOcA" target="_blank" rel="noopener">【第1276期】JSON Schema 那些事儿：基本概念</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/MvP3GelJzbnY6ct-5u9bZA" target="_blank" rel="noopener">【第1275期】基于node.js平台的脚手架开发经历</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/2ViqE4U5beZcKgIHVimuqg" target="_blank" rel="noopener">【第1274期】ES6之路之模块详解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/nOlWqF7m1b4jGL-sKIB-dg" target="_blank" rel="noopener">【第1273期】React性能优化-虚拟Dom原理浅析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/m8atIJzGEGnOV_utpijG2g" target="_blank" rel="noopener">【第1272期】从零开始搭建脚手架</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/dc0iQX1M2SdmdyUGT9qzMA" target="_blank" rel="noopener">【第1271期】Webpack4+ 多入口程序构建</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/uaT76CkguNj0rxqRxxRpOA" target="_blank" rel="noopener">【第1270期】老树发新芽—使用 mobx 加速你的 AngularJS 应用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228617&amp;idx=1&amp;sn=3e6cbc550e2c8fd5aaf82a3a1f5941d0" target="_blank" rel="noopener">【第1269期】基于React实战分享WeatherApp</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228572&amp;idx=1&amp;sn=083cf3e657d7a45351645515f38ad4e8" target="_blank" rel="noopener">【第1268期】字蛛+发布！支持动态渲染、远程多页面字体压缩</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228568&amp;idx=1&amp;sn=24421209ed6d359f4d416737d19934ae" target="_blank" rel="noopener">【第1267期】基于Docker+Consul+Registrator+Nodejs实现服务治理（二）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228562&amp;idx=2&amp;sn=83d70d4f484f04ba05eec0fc9b3c80f7" target="_blank" rel="noopener">【第1266期】基于Docker+Consul+Registrator+Nodejs实现服务治理（一）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228541&amp;idx=1&amp;sn=50d27f19e54af34eef7d8820f0fa269e" target="_blank" rel="noopener">【第1265期】那些前端MVVM框架是如何诞生的</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228538&amp;idx=1&amp;sn=27b7c8d5d2619652f0ec130b6abbe919" target="_blank" rel="noopener">【第1264期】UX专家如何做设计评审</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228535&amp;idx=1&amp;sn=06d7aba782e719c2db719f749d13962a" target="_blank" rel="noopener">【第1263期】我当初为什么写webpack</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228532&amp;idx=2&amp;sn=877a6736c0f5363b605ad09a891c70cb" target="_blank" rel="noopener">【第1262期】Jenkins打造强大的前端自动化工作流</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228528&amp;idx=1&amp;sn=7902da53fa7e98d6c32d61663a73e239" target="_blank" rel="noopener">【第1261期】那些好玩却尚未被 ECMAScript 2017 采纳的提案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228520&amp;idx=1&amp;sn=f93473a6f06a7a10e268c10a3c7524a9" target="_blank" rel="noopener">【第1260期】图说 ES Modules</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228484&amp;idx=1&amp;sn=d6f2801125e1743d803d3ec365facb66" target="_blank" rel="noopener">【第1259期】Nerv实战 - 京东首页改版小结</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228474&amp;idx=1&amp;sn=031ea46ca182f2dacf8f65cc30c6566b" target="_blank" rel="noopener">【第1258期】从JS垃圾回收机制和词源来透视闭包</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228457&amp;idx=2&amp;sn=eb3c0308ca99d0bf60c682c44c00d258" target="_blank" rel="noopener">【第1257期】YAML 语言教程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228450&amp;idx=1&amp;sn=ed4c0323bddaf3ad91c8a8e429bccf6e" target="_blank" rel="noopener">【第1256期】JavaScript反调试技巧</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228442&amp;idx=1&amp;sn=0b7e053a66a144adf7c544fd5b4dd902" target="_blank" rel="noopener">【第1255期】超大型 JavaScript 应用的设计哲学</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228436&amp;idx=1&amp;sn=a92a814cff43ed348d740dad6cd98774" target="_blank" rel="noopener">【第1254期】用CSS Houdini画一片星空</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228431&amp;idx=1&amp;sn=c9d62a30a52f4572cc0cb4aaf2a82ef3" target="_blank" rel="noopener">【第1253期】柯里化函数应用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228430&amp;idx=1&amp;sn=eb1a928d5b850fb4686b3c07be10b7b4" target="_blank" rel="noopener">【第1252期】Webpack基本架构浅析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228412&amp;idx=2&amp;sn=e67d7cab6813c26a27bb63d5469b185d" target="_blank" rel="noopener">【第1251期】玩转HTML5 Video视频WebVTT字幕使用样式与制作</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228395&amp;idx=1&amp;sn=dcf7e3bd518f1e189ce17eaed94c27bb" target="_blank" rel="noopener">【第1250期】彻底理解浏览器的缓存机制</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228362&amp;idx=1&amp;sn=f7eaeacf14fbab1affef8019109697a0" target="_blank" rel="noopener">【第1249期】使用 CSS 来做素数的判定与筛选</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228360&amp;idx=1&amp;sn=102813361f273388bc5e7acbb82711f6" target="_blank" rel="noopener">【第1248期】ECMAScript 2016, 2017, 和2018中新增功能</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228354&amp;idx=1&amp;sn=1b2e751dcbefbd674319b5055651c80b" target="_blank" rel="noopener">【第1247期】使用圆锥渐变和CSS变量创建一个Range Input控制的环形图</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228353&amp;idx=1&amp;sn=0e26b3be7314331d0ed2174d358c7f54" target="_blank" rel="noopener">【第1246期】设计师与工程师协作的 5 项准则</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228321&amp;idx=1&amp;sn=799c6acadaf12afc4e47416cf9d120ef" target="_blank" rel="noopener">【第1245期】前端调试清单之优化网络资源</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228311&amp;idx=2&amp;sn=31af8092ec9cf08b701b4681c7a0f05f" target="_blank" rel="noopener">【第1244期】详解Object.create(null)</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228287&amp;idx=2&amp;sn=d05fe886754a779812f06d08409df8ea" target="_blank" rel="noopener">【第1243期】一次掌握 JavaScript ES5 到 ES8 数组内容</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228283&amp;idx=1&amp;sn=71adfdccab8e92b5b6403e57b321944a" target="_blank" rel="noopener">【第1242期】 开始使用新的 CSS Typed Object Model</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228270&amp;idx=1&amp;sn=48335524405d1a08946e63edfd2ba6ff" target="_blank" rel="noopener">【第1241期】webpack4升级完全指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228265&amp;idx=2&amp;sn=2789e445c1dead03d64216583dd3aac5" target="_blank" rel="noopener">【第1240期】passive 事件监听</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228253&amp;idx=1&amp;sn=d01d35d69485b1e61f64bab76c795c3b" target="_blank" rel="noopener">【第1239期】关于Google发布的JS代码规范，你需要了解什么？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228249&amp;idx=1&amp;sn=0095eb2a5207a8bfe6f18a4b6ae93684" target="_blank" rel="noopener">【第1238期】如何做一名有能力的专业人士</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228246&amp;idx=1&amp;sn=4e6ae387ac979772509ed1828afa32df" target="_blank" rel="noopener">【第1237期】Service workers：PWA背后的英雄</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228242&amp;idx=1&amp;sn=711ec5867ec729fac1aba4e69e616d9a" target="_blank" rel="noopener">【第1236期】探索基于 WebGL 的动画与交互</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228225&amp;idx=1&amp;sn=a4775a9f1fc2a348c36bc5ad0e71656d" target="_blank" rel="noopener">【第1235期】动画：从 AE 到 Web</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228218&amp;idx=1&amp;sn=331089970ce00fb99754bc115c78c5d6" target="_blank" rel="noopener">【第1234期】前端布局基础概述</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228160&amp;idx=1&amp;sn=b0af9e9cebf4f4a5085539a11c5a7538" target="_blank" rel="noopener">【第1233期】QQ会员活动运营平台演变和技术实践——高效活动运营</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228155&amp;idx=1&amp;sn=0269f3959d05c579076767ffaeb6cc21" target="_blank" rel="noopener">【第1232期】Excuse me？这个前端面试在搞事！</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228154&amp;idx=1&amp;sn=881c96d22e4e5e8c53a58886064def55" target="_blank" rel="noopener">【第1231期】热爱 JavaScript，但是讨厌 CSS ？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228145&amp;idx=1&amp;sn=00067cb6c49abc241e41fa3b1cb005af" target="_blank" rel="noopener">【第1230期】从头实现一个koa框架</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228137&amp;idx=1&amp;sn=9e07bb64d9f9b3d89c4ce234e3e3cdea" target="_blank" rel="noopener">【第1229期】程序员如何在技术浪潮的更迭中保持较高的成长速度 ？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228133&amp;idx=1&amp;sn=144fc8e194d362a3be77b300bf50acae" target="_blank" rel="noopener">【第1228期】画一条0.5px的边</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228130&amp;idx=1&amp;sn=c48f7e08b95d81004b42802046da706c" target="_blank" rel="noopener">【第1227期】关于 CSS 变量，你需要了解的一切</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228125&amp;idx=1&amp;sn=a9f50b57d37b51e684fb9ee8d8b5bdec" target="_blank" rel="noopener">【第1226期】AMP项目实战分享</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228121&amp;idx=1&amp;sn=a31e1a215ffdda13892f5adc28954d17" target="_blank" rel="noopener">【第1225期】手拉手，用Vue开发动态刷新Echarts组件</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228120&amp;idx=1&amp;sn=b6657f8f177789bc7cbc7560310df920" target="_blank" rel="noopener">【第1224期】追根溯源：箭头函数的前世今生</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228102&amp;idx=1&amp;sn=8f56701827e0226efc18b6bfb28d044d" target="_blank" rel="noopener">【第1223期】最全最好用的动效落地方法、都帮你总结好了（下）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228096&amp;idx=1&amp;sn=8c152a2d07d66e34616f6c2d6929e1e7" target="_blank" rel="noopener">【第1222期】十倍效能提升——Web 基础研发体系的建立</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228093&amp;idx=2&amp;sn=81eb436c61117eee8814359e3a31ce07" target="_blank" rel="noopener">【第1221期】开始设计动画的九个步骤：为作品赋予生命力</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228069&amp;idx=1&amp;sn=76f8e4194944d4ef40398bce0dbd9b32" target="_blank" rel="noopener">【第1220期】关于 HTML 语义和前端架构</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228065&amp;idx=2&amp;sn=0db2e69aa9344d4b086e9d98301aebad" target="_blank" rel="noopener">【第1219期】从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228063&amp;idx=1&amp;sn=84e042300471fb32634baa32916244b0" target="_blank" rel="noopener">【第1218期】DNS：为什么很重要&amp;是如何工作的</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228053&amp;idx=1&amp;sn=38e580fcf3d059120c4498cdaa4a20a0" target="_blank" rel="noopener">【第1217期】用JavaScript写一个区块链</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228038&amp;idx=1&amp;sn=c42cf9cab1eb6672fde6c239e293d549" target="_blank" rel="noopener">【第1216期】最全最好用的动效落地方法、都帮你总结好了（上）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227998&amp;idx=2&amp;sn=78951a5cc7681f90d57fd72ef397a710" target="_blank" rel="noopener">【第1215期】基于Webpack4使用懒加载分离打包React代码</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227985&amp;idx=1&amp;sn=2d2278de3a921d33d01561ba0ed062f3" target="_blank" rel="noopener">【第1214期】帆布指纹识别</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227981&amp;idx=1&amp;sn=bde571dee8116dbc9daa75763b4fa9af" target="_blank" rel="noopener">【第1213期】优雅的提交你的 Git Commit Message</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227974&amp;idx=1&amp;sn=dd289bbf2b0aa2ee98abec203281e370" target="_blank" rel="noopener">【第1212期】从平面设计师到前端工程师：五个月的转变历程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227961&amp;idx=1&amp;sn=d4eb72b910281a18fc35581e0e39096f" target="_blank" rel="noopener">【第1211期】危险的 target=”_blank” 与 “opener”</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227926&amp;idx=1&amp;sn=78e203ab8891048ceb42ce8aaf0c260f" target="_blank" rel="noopener">【第1210期】前端开发、交互、视觉是怎么合作完成工作的</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227913&amp;idx=1&amp;sn=c2f7636b00f4e70736c7047f23bd309a" target="_blank" rel="noopener">【第1209期】关于 Promise 的 9 个提示</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/2H6x5a-sjUYngMgC0FdAsw" target="_blank" rel="noopener">【第1208期】AngularJS 1.x平滑升级Angular实战</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227891&amp;idx=1&amp;sn=0333eb02740b5fc719c8023bc3ede302" target="_blank" rel="noopener">【第1207期】TypeScript 实践分享</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227882&amp;idx=1&amp;sn=b48093351f3e52ec281c29ee9cb5d600" target="_blank" rel="noopener">【第1206期】看清楚真正的 Webpack 插件</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227878&amp;idx=1&amp;sn=efba8a8f27eb0e34ece80bc305a0e02d" target="_blank" rel="noopener">【第1205期】网络现状：性能提升指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227874&amp;idx=1&amp;sn=11a6bc9753aa4f5b8c8ad6688157d05d" target="_blank" rel="noopener">【第1204期】Julie Zhuo谈如何思考职业发展</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227873&amp;idx=1&amp;sn=c829c160e91ea6bce57d3673dfc8c111" target="_blank" rel="noopener">【第1203期】webpack 4 发布了！</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227860&amp;idx=1&amp;sn=0cd17bc716a676b9904c465166087f28" target="_blank" rel="noopener">【第1202期】手淘过年项目中采用到的前端技术</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227852&amp;idx=1&amp;sn=b14ad9643305ea75291804d1663747ff" target="_blank" rel="noopener">【第1201期】Node 定时器详解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227848&amp;idx=1&amp;sn=536dcf60dd2d9df86d4092bd4c2cef9e" target="_blank" rel="noopener">【第1200期】React 是怎样炼成的</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227829&amp;idx=1&amp;sn=b4ae3261e63665a7bc0c24fb5dc8fe99" target="_blank" rel="noopener">【第1199期】10 种最常见的 Javascript 错误</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227810&amp;idx=1&amp;sn=1f282b80e993b7b6eb11c5ce7aec2a0a" target="_blank" rel="noopener">【第1198期】JavaScript 中的私有变量</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227807&amp;idx=1&amp;sn=279fb7923e9de22d7909fb36ae4964c4" target="_blank" rel="noopener">【第1197期】iOS 11.3 支持PWA了，然而……</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227803&amp;idx=1&amp;sn=aa90993cf4711f99f6f8203cf2fb4e6b" target="_blank" rel="noopener">【第1196期】原生JS数据绑定</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227799&amp;idx=1&amp;sn=0128323a196af43994a527499933b82f" target="_blank" rel="noopener">【第1195期】现代CSS进化史</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227786&amp;idx=1&amp;sn=e15b331e7231e574a0c28efa8cdd76e4" target="_blank" rel="noopener">【第1194期】手把手教你用 SVG 符号和 CSS 变量做出彩色图标</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227780&amp;idx=1&amp;sn=81b4d9ca583f1ccc8c2d3e128535349b" target="_blank" rel="noopener">【第1192期】记“编写babel插件”与“通过语法解析替换小程序路由表”的经历</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227774&amp;idx=1&amp;sn=45c433a33557af12a9a79ecd6483f713" target="_blank" rel="noopener">【第1192期】假如测试说你的网站在iOS 10有问题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227769&amp;idx=1&amp;sn=617160e64d2be13169b1b8f4506d8801" target="_blank" rel="noopener">【第1191期】你所忽略的js隐式转换</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227761&amp;idx=1&amp;sn=40c851adac033a5db45b2db743233be2" target="_blank" rel="noopener">【第1190期】完美升级 AngularJS 至 Angular</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/f-j2BB4fGpPsaJTQXzKSeA" target="_blank" rel="noopener">【第1189期】2018 前端性能优化清单之四</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227748&amp;idx=1&amp;sn=852df25adac18b9f3b12db08cd9e3284" target="_blank" rel="noopener">【第1188期】2018 前端性能优化清单之三</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227743&amp;idx=1&amp;sn=0df7fe2d9d39c07723cd2d12d6a40675" target="_blank" rel="noopener">【第1187期】2018 前端性能优化清单之二</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227739&amp;idx=1&amp;sn=207c38c25bfef24b76eb2011a5feb241" target="_blank" rel="noopener">【第1186期】Webpack v4 beta 版本发布</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227729&amp;idx=1&amp;sn=1e2578c24fd239716ef67b73d54c19db" target="_blank" rel="noopener">2018 前端性能优化清单之一</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227724&amp;idx=2&amp;sn=5bde78da0f0368feb1012ae9485a7394" target="_blank" rel="noopener">【第1184期】滴滴后市场前端技术体系</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227719&amp;idx=1&amp;sn=b72d098aa0f55f63d273cbe3c006c92d" target="_blank" rel="noopener">【第1183期】这些 CSS 命名规范，将省下你大把调试时间</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227701&amp;idx=1&amp;sn=01f3178dbc526a3aae6337093f9f4821" target="_blank" rel="noopener">【第1181期】XSwitch - 一个解决本地开发请求转发的浏览器插件</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227689&amp;idx=1&amp;sn=2468b86114f3e77c9d259e18c2ab9839" target="_blank" rel="noopener">【第1180期】迎接新的 Dialog 元素</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227679&amp;idx=1&amp;sn=60348903ea5cfe9232e6618e2a6ed8be" target="_blank" rel="noopener">【第1179期】在微信、微博、QQ、Safari唤起App的解决方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227675&amp;idx=1&amp;sn=024b01082bef3b344edcca5f92bafb55" target="_blank" rel="noopener">【第1178期】WebSocket：5分钟从入门到精通</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227672&amp;idx=1&amp;sn=d25bf9e91e75df1b1c89b86e66a2893f" target="_blank" rel="noopener">【第1177期】新的包名规则</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227663&amp;idx=1&amp;sn=b2cc7801d882526604e249632b6a6b4d" target="_blank" rel="noopener">【第1176期】前后端分离实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227662&amp;idx=1&amp;sn=21fd143330288f585585baccc8ee7c76" target="_blank" rel="noopener">【第1175期】2017年 JavaScript 明星项目</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227661&amp;idx=1&amp;sn=16997dba48e249aeba34cebbe1447ee3" target="_blank" rel="noopener">【第1174期】Crooked Style Sheets：只用CSS实现网页跟踪、分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227651&amp;idx=2&amp;sn=b57166e0b58c2b69972aaa8dfbe60caa" target="_blank" rel="noopener">【第1173期】npm 2017 JavaScript 框架报告之前端框架</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227645&amp;idx=1&amp;sn=64ebca98ff7b26b2fb4cf858b4154d26" target="_blank" rel="noopener">【第1172期】HTML 5.2 有哪些新内容？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227644&amp;idx=1&amp;sn=db15a422311553ec1762a6be19cfb234" target="_blank" rel="noopener">【第1171期】npm 2017 JavaScript 框架报告之后端框架</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227611&amp;idx=1&amp;sn=f321f6acf71162f80423c055cb699a46" target="_blank" rel="noopener">【第1170期】如何看待员工跳槽</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227607&amp;idx=1&amp;sn=00f9adba3ebdb1f4e9e982148fbfc151" target="_blank" rel="noopener">【第1169期】如何有效地做算法题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227606&amp;idx=1&amp;sn=7d296c6779f32470737f56c8eeed394e" target="_blank" rel="noopener">【第1168期】字符编码的故事</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227605&amp;idx=1&amp;sn=2c0cfcfa7aa49a718430002ed1a85311" target="_blank" rel="noopener">【第1167期】npm 2017 JavaScript 框架报告之 React 生态系统分析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227598&amp;idx=1&amp;sn=9b993810b1a884202c3c39000cca8308" target="_blank" rel="noopener">【第1166期】Ant Design 3.0 背后的故事（含演讲视频）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227581&amp;idx=1&amp;sn=51fa53c41b6c6bc6a5cdd742eefdd9aa" target="_blank" rel="noopener">【第1165期】H5动画：轨迹移动</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cIM4KA-4EaT3wdxLuIpBBg" target="_blank" rel="noopener">【第1164期】从前端技术到体验科技</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227571&amp;idx=1&amp;sn=b9c4088ea028e68d36f8145d88787b00" target="_blank" rel="noopener">【第1163期】React 整洁代码最佳实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227567&amp;idx=2&amp;sn=c6fa2baa428b7dc8295fb23699855b80" target="_blank" rel="noopener">【第1162期】2018 要学习的优秀 JavaScript 库与知识</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227560&amp;idx=1&amp;sn=77b7feae31286f431a1bec3e843669d7" target="_blank" rel="noopener">【第1161期】从Chrome源码看DNS解析过程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227557&amp;idx=1&amp;sn=830c8e02a41051924a3dc584656b3034" target="_blank" rel="noopener">【第1160期】Ant Design 色板生成算法演进之路</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227553&amp;idx=1&amp;sn=1f4d729b93ab2a4a9450038af67ce0f0" target="_blank" rel="noopener">【第1159期】CSS预加载Preload</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227549&amp;idx=1&amp;sn=2807e8582423a60ae8b321af39f860f8" target="_blank" rel="noopener">【第1158期】哔哩哔哩的前端之路</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227545&amp;idx=2&amp;sn=f88779f91ceab07ccbbf7e2fdcd69316" target="_blank" rel="noopener">【第1157期】PNG格式小图标的CSS任意颜色赋色技术</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227541&amp;idx=1&amp;sn=9f3849e83ba2a3e9626983c3d2390a11" target="_blank" rel="noopener">【第1156期】Chrome DevTools - 性能监控</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227527&amp;idx=1&amp;sn=514367d931d53b6d4cd13f077568c099" target="_blank" rel="noopener">【第1155期】如何快速融入新团队？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227526&amp;idx=1&amp;sn=4e51533aa97ff681b6465d32947f2bab" target="_blank" rel="noopener">【第1154期】2017 年 JavaScript 发展状况回顾</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227517&amp;idx=1&amp;sn=856f50820039238e9698e78a8c76e842" target="_blank" rel="noopener">【第1153期】设计师如何有效参与团队协作</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227516&amp;idx=1&amp;sn=ebe442939a5602521505d64de7702a20" target="_blank" rel="noopener">【第1152期】2017 JavaScript 调查报告概述</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227509&amp;idx=2&amp;sn=ff74eb1377ae55304421c0c68af44f93" target="_blank" rel="noopener">【第1151期】技术的热门度曲线</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227502&amp;idx=1&amp;sn=b71dff2959dc02219d8171501d3004e4" target="_blank" rel="noopener">【第1150期】CSS工程化演进</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227495&amp;idx=1&amp;sn=96ed2db1d5408db547a778903eba6efc" target="_blank" rel="noopener">【第1149期】WEB即时通信最佳实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227494&amp;idx=1&amp;sn=444001447adef73ae8066ddfd1a01ddc" target="_blank" rel="noopener">【第1148期】把前端监控做到极致</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227486&amp;idx=1&amp;sn=f51896245be0d0325384a97fc353bd55" target="_blank" rel="noopener">【第1147期】webpack 为什么这么难用？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227481&amp;idx=1&amp;sn=285474582a69e879ed20ce61b067ea83" target="_blank" rel="noopener">【第1146期】谈谈Javascript中的void操作符</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227479&amp;idx=1&amp;sn=3eb1501b3c3041fd9c7afdda0d180ead" target="_blank" rel="noopener">【第1145期】打造高可靠与高性能的React同构解决方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227472&amp;idx=2&amp;sn=c2bd881c28cdabdb7bdff0337eb0f5b0" target="_blank" rel="noopener">【第1144期】2017前端技术发展回顾</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227470&amp;idx=1&amp;sn=68c59d96df36c3fa9e9b2daa8e50b4c6" target="_blank" rel="noopener">【第1143期】优化移动端window.onscroll的执行频率方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227464&amp;idx=2&amp;sn=18c04a0e67a601a9d6c0ae666bbba189" target="_blank" rel="noopener">【第1142期】Git提交历史的修改删除合并等实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227463&amp;idx=1&amp;sn=4e039c6bce3a987faff10873b06004f0" target="_blank" rel="noopener">【第1141期】Weex在达人店的一年实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227446&amp;idx=1&amp;sn=9c64ed9cd93efa3a7232fd12b46e9d1a" target="_blank" rel="noopener">【第1140期】如何让异步接口同时支持 callback 和 promise</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227441&amp;idx=1&amp;sn=183035f3b15af8ddb071d7e081c4a485" target="_blank" rel="noopener">【第1139期】基于Gitlab CI搭建持续集成环境</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227435&amp;idx=2&amp;sn=3ebe8df545436c3ef2cd1443305a5a4e" target="_blank" rel="noopener">【第1138期】import、require、export、module.exports 混合详解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227428&amp;idx=1&amp;sn=4bbde857fa7ac19fccba84385f648f27" target="_blank" rel="noopener">【第1137期】软件工程师的职业建议</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227425&amp;idx=1&amp;sn=9d54f1e2e9954fc4d7104a6be9d94c2f" target="_blank" rel="noopener">【第1136期】零配置的 Web 应用打包工具 - Parcel</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227422&amp;idx=1&amp;sn=62f574bf62045f2214f11f42e011e68c" target="_blank" rel="noopener">【第1135期】CSS简史</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227419&amp;idx=1&amp;sn=67dffa9dfcfaba789e0b5a43c9410ffe" target="_blank" rel="noopener">【第1134期】如何用人类的方式进行 Code Review （二）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227416&amp;idx=1&amp;sn=d07c16e05589205a5d9ad22988c3c76e" target="_blank" rel="noopener">【第1133期】构建离线web应用二</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227410&amp;idx=1&amp;sn=403bfcc2cbfaa9a11e3f9b753059e75e" target="_blank" rel="noopener">【第1132期】如何用人类的方式进行 Code Review</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227406&amp;idx=1&amp;sn=9360599bc59fa99650009c5e5feec141" target="_blank" rel="noopener">【第1131期】对于网络爬虫技术的攻与防</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227400&amp;idx=1&amp;sn=9c6fb2f13e788d0f6ffb662fe2198165" target="_blank" rel="noopener">【第1130期】JavaScript 的时间消耗</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227396&amp;idx=1&amp;sn=a493193d1e12148df7ecb54cb8a814a6" target="_blank" rel="noopener">【第1129期】对vue.js单文件（.vue）进行单元测试</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227392&amp;idx=1&amp;sn=790fcc897f55f7638f7253fe3c8d5b6d" target="_blank" rel="noopener">【第1128期】从北京回来的年轻人，该告诉你点什么？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227391&amp;idx=1&amp;sn=59edb32e8146a1c277c2a91911d249cb" target="_blank" rel="noopener">【第1127期】H5玩法知多少</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227381&amp;idx=1&amp;sn=e16d9525319d8c36d06a4e395d205ef1" target="_blank" rel="noopener">【第1126期】重新组织git本地提交</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227371&amp;idx=1&amp;sn=276f20ad2116a806b4f8e610348cbb76" target="_blank" rel="noopener">【第1125期】GraphQL 技术栈揭秘</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227366&amp;idx=1&amp;sn=201cdac9414694590d98689768685414" target="_blank" rel="noopener">【第1124期】Vue.js 升级踩坑小记</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227359&amp;idx=1&amp;sn=978d006da2f238fd18c3168a9bc7dcfc" target="_blank" rel="noopener">【第1123期】注释的艺术</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227354&amp;idx=1&amp;sn=247baaa095c7823ec142b9a6e9c7d7bd" target="_blank" rel="noopener">【第1122期】运动模式对应的心理预期</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227351&amp;idx=1&amp;sn=c3088d29e7b5267b5b50daab94e94632" target="_blank" rel="noopener">【第1121期】探究 CSS 解析原理</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227350&amp;idx=1&amp;sn=76b4ea43fb7589374776d97f50a8fb5a" target="_blank" rel="noopener">【第1120期】iOS 开发是否要采用 React Native?</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227335&amp;idx=1&amp;sn=54bbf426f7b8358fddcb4a3901255eb3" target="_blank" rel="noopener">【第1119期】Git的4个阶段的撤销更改</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227328&amp;idx=1&amp;sn=10905c6d63ddadb3690d61b2aff864b0" target="_blank" rel="noopener">【第1118期】2018校招面试经验分享</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227323&amp;idx=2&amp;sn=ec12be7a26e897ba838fb3f3e07bdc97" target="_blank" rel="noopener">【第1117期】萌新也能懂的现代 JavaScript 开发</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227318&amp;idx=1&amp;sn=6776c93e3a1431f446b18f87768a2792" target="_blank" rel="noopener">【第1116期】前端需要了解的 SSO 与 CAS 知识</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227315&amp;idx=2&amp;sn=370481aeaeaea5931efd9b65a02b6c75" target="_blank" rel="noopener">【第1115期】Puppeteer: 更友好的 Headless Chrome Node API</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227310&amp;idx=1&amp;sn=3f6a660bf59c4113791b26f2571aa5e3" target="_blank" rel="noopener">【第1114期】打造高性能剪切动画</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227306&amp;idx=1&amp;sn=b9d488f3a60183e74ad911f2f9887e7c" target="_blank" rel="noopener">【第1113期】Firefox Quantum、Google Chrome 63 Beta</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227302&amp;idx=1&amp;sn=895be76d6e20903166516331a96b4ff7" target="_blank" rel="noopener">【第1112期】前端 Console 调试小技巧</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227297&amp;idx=1&amp;sn=b0f6ad5b75faa4748c69bd656eb5161a" target="_blank" rel="noopener">【第1111期】Subresource Integrity 介绍</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227291&amp;idx=2&amp;sn=42ac69565896c68cec5ecedbef402ed9" target="_blank" rel="noopener">【第1110期】SVG 路径动画简易指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227285&amp;idx=1&amp;sn=0afd4cbcb7be16f3b6dd0aa093746dfa" target="_blank" rel="noopener">【第1109期】JavaScript函数的多种写法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227281&amp;idx=1&amp;sn=8117eeaa843ca8ea525c1af615d9a7f0" target="_blank" rel="noopener">【第1108期】小白谈数据脱敏</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227274&amp;idx=1&amp;sn=e06ba689991bf4be168e50e44994b035" target="_blank" rel="noopener">【第1107期】iPhone X 适配 手Q H5页面通用解决方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227271&amp;idx=1&amp;sn=a3cd7ae5657af45e16426c78ea399d82" target="_blank" rel="noopener">【第1106期】Element 中的键盘可访问性</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227265&amp;idx=1&amp;sn=c3878483a4d76baa8dd1985411ff4ddc" target="_blank" rel="noopener">【第1105期】Preact：一个备胎的自我修养</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227260&amp;idx=1&amp;sn=7471c6326c41ab56d9653948ab5803a8" target="_blank" rel="noopener">【第1104期】14 个你可能不知道的 JavaScript 调试技巧</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227257&amp;idx=1&amp;sn=be85c150f86d0e4918a5c9e5c246a192" target="_blank" rel="noopener">【第1103期】vue 自定义指令的魅力</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227254&amp;idx=1&amp;sn=d534cc317ab3ad034b632810f7351127" target="_blank" rel="noopener">【第1102期】编写扁平化的代码</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227249&amp;idx=1&amp;sn=614fa823162f65dd219546964bcbd3a3" target="_blank" rel="noopener">【第1101期】HTTPS中S带来的性能损失</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227242&amp;idx=1&amp;sn=4ef4590eb145ae4dc78639ea7be26829" target="_blank" rel="noopener">【第1100期】经常加班，怎么兼顾个人能力提升？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;公众号-前端早读课推文列表&quot;&gt;&lt;a href=&quot;#公众号-前端早读课推文列表&quot; class=&quot;headerlink&quot; title=&quot;公众号-前端早读课推文列表&quot;&gt;&lt;/a&gt;公众号-前端早读课推文列表&lt;/h2&gt;&lt;p&gt;每两周更新&lt;/p&gt;
&lt;p&gt;部分参考： &lt;a href=&quot;https://github.com/if2er/FeZaoDuKe-Collection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/if2er/FeZaoDuKe-Collection&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_z_MRVb-O-Xfj-9Qael7wA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1476期】如何提升设计到开发的协作效率&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/V7HJJUpd40yd0y03aMyJVw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1475期】企鹅辅导课程详情页毫秒开的秘密 - PWA 直出&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qBD90RdofvYDNX2sSJWgNA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1474期】HTTP/3 要点&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7qBU5gGq5Tv2QEzuHDF7gg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1473期】用代码做设计&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/iHDium37WsmWxbKwhOVsgA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1472期】我们为什么要写 super(props)?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/EnS22WGKiXnTCdFnqrVahA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1471期】AST抽象语法树——最基础的javascript重点知识&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/SQfIImIBKfSvDjITz2h_Mw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1470期】为什么前端工程师需要关注设计&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/xXPAkfQkmkWWK_2HCyE7Mg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【第1469期】篡改NPM包盗取比特币始末&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="总结归纳" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    
    
      <category term="总结归纳" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js个人经验总结</title>
    <link href="http://yoursite.com/2018/12/27/Vue.js%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/27/Vue.js个人总结/</id>
    <published>2018-12-27T07:11:06.740Z</published>
    <updated>2018-12-27T07:14:28.952Z</updated>
    
    <content type="html"><![CDATA[<p>其实Vue里，在我们开发中，大多数的东西我们都可以在vue.js的官网里找到。但是也有些 在你封指令或者组件时候。有更便捷的方法，或者可以用高级用法来形容。</p><a id="more"></a><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><blockquote><p>除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子<br>当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注册一个全局自定义指令 `v-focus`</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>如果想注册局部指令，组件中也接受一个 directives 的选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    // 指令的定义</span><br><span class="line">    inserted: function (el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure></p><p>例如 VUX里面也提供了 TransferDom 的自定义指令。 </p><h3 id="this-forUpdate"><a href="#this-forUpdate" class="headerlink" title="this.$forUpdate()"></a>this.$forUpdate()</h3><blockquote><p>this.$forceUpdate() 处理页面刷新问题（v-for循环值刷新等）<br>问题描述：在使用Vue框架开发时，在函数中改变了页面中的某个值，在函数中查看是修改成功了，但在页面中没有及时刷新改变后的值<br>解决：运用 this.$forceUpdate() 强制刷新（因为数据层次太多，render函数没有自动更新，需手动强制刷新。）<br>用法: 在for循环后添加  。或者点击事件的时候， 需要改变某些状态值<br>this.$forceUpdate(); //强制刷新，<strong>解决页面不会重新渲染的问题</strong></p></blockquote><h3 id="vuex中，表单利用state的值的时候。-可以利用计算属性的set-value-去进行计算属性的双向绑定。更简单"><a href="#vuex中，表单利用state的值的时候。-可以利用计算属性的set-value-去进行计算属性的双向绑定。更简单" class="headerlink" title="vuex中，表单利用state的值的时候。 可以利用计算属性的set(value).去进行计算属性的双向绑定。更简单"></a>vuex中，表单利用state的值的时候。 可以利用计算属性的set(value).去进行计算属性的双向绑定。更简单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;input v-model=&quot;message&quot;&gt;</span><br><span class="line">JS:</span><br><span class="line">computed: &#123;</span><br><span class="line">  message: &#123;</span><br><span class="line">    get () &#123;</span><br><span class="line">      return this.$store.state.obj.message</span><br><span class="line">    &#125;,</span><br><span class="line">    set (value) &#123;</span><br><span class="line">      this.$store.commit(&apos;updateMessage&apos;, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.js里面的</span><br><span class="line">mutations: &#123;</span><br><span class="line">  updateMessage (state, message) &#123;</span><br><span class="line">    state.obj.message = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在严格模式下的使用vuex。 不能直接在v-model用vuex中的state中的值。<br>因为能修改state的值。 唯一路径 还是mutations</p><h3 id="Vue-出现的一些错误-Uncaught-TypeError-fn-bind-is-not-a-function"><a href="#Vue-出现的一些错误-Uncaught-TypeError-fn-bind-is-not-a-function" class="headerlink" title="Vue 出现的一些错误 Uncaught TypeError: fn.bind is not a function"></a>Vue 出现的一些错误 Uncaught TypeError: fn.bind is not a function</h3><pre><code>检查一下methods里面嵌套的东西。 看会不会结构有问题</code></pre><h3 id="iconfont的基本用法"><a href="#iconfont的基本用法" class="headerlink" title="iconfont的基本用法"></a>iconfont的基本用法</h3><p>1.把需要的icon添加到购物车<br>2.如果需要哪个的话，添加到自己的项目之中。<br>3.然后点击我的项目。 可以看到自己需要的图标。 和对应的图标代码。<br>4.然后可以在该页面点击下载至我的本地。 然后进行相关操作<br>5.下载iconfont.在asserts文件夹中。然后放入文件iconfont.css 创建iconfont. 放入文件iconfont.eot，iconfont.svg，iconfont.ttf，iconfont.woff。<br>6.对于每次下载之后。 在文件夹iconfont里面的4个文件。 需要重新替换。<br>7.在iconfont.css 需要更新64位的url. 把下载回来的iconfont中的64位替换之前的64位代码。– url(‘data:application/x-font-woff;charset=utf-8;base64,**–(因为第一次上面的src的路径，我们已经把绝对路径写好了。如果我们直接用最新的iconfont.css的话，又要写多一次路径。 所以直接改一次64位的就好了。 其它的就不用理了)<br>最后 在Main.js import ‘styles/iconfont.css’。</p><h3 id="css3-渐变属性-background-image-linear-gradient-top-rgba-0-0-0-0-rgba-0-0-0-0-8"><a href="#css3-渐变属性-background-image-linear-gradient-top-rgba-0-0-0-0-rgba-0-0-0-0-8" class="headerlink" title="css3 渐变属性  background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));"></a>css3 渐变属性  background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));</h3><p>一个div 从一个方向到另外一个方向的样式渐变。 用 linear-gradient。<br>第一个属性为方向（会往反方向渐变）。 第二个是初始颜色值。 第三个是到最终方向的颜色值。   —- 这是基础方法。 其中过渡的话。 可以看网站教学<br>background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));等于<br>background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));<br>详解：<a href="http://www.php.cn/css-tutorial-362595.html" target="_blank" rel="noopener">http://www.php.cn/css-tutorial-362595.html</a><br>参数解释：<a href="http://www.php.cn/css-tutorial-362594.html" target="_blank" rel="noopener">http://www.php.cn/css-tutorial-362594.html</a></p><h3 id="swiper学习"><a href="#swiper学习" class="headerlink" title="swiper学习"></a>swiper学习</h3><p>在我做过的这个项目之中。 虽然说vux是vue官网推荐使用的组件库。 不过swiper的话。 我觉的官网的比较好用。</p><h3 id="用keep-alive-包住的组件里面有better-scroll—-PC可以滑动。手机端偶现不能滑动"><a href="#用keep-alive-包住的组件里面有better-scroll—-PC可以滑动。手机端偶现不能滑动" class="headerlink" title="用keep-alive 包住的组件里面有better-scroll— PC可以滑动。手机端偶现不能滑动"></a>用keep-alive 包住的组件里面有better-scroll— PC可以滑动。手机端偶现不能滑动</h3><p>em….最近在做一个项目。 突然发现用手机测试我做的项目的时候，被keep-alive包住的Better-scroll 不能滑动。 在网上找了很多，却不能找到解决方法。 后面记起了自己原来用keep-alive包住了这个组件。… 网上的人说keep-alive会有缓存作用，也会记录组件的位置。 就算我们跳转的时候，路由设置初始化高度到顶部，也会让这个better-scroll不能滑动。<br>后来发现看过一些文章。 用手机测试的时候，会有一些缓存机制。 会记录上个页面的信息。 .. 会导致better-scroll不能滑动（我也没多清楚）<br>解决方法：就是在activated函数 重新启动better-scroll<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activated()&#123;</span><br><span class="line">  this.scroll = new BScroll(this.$refs.wrapper);</span><br><span class="line">  this.scroll.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><h3 id="由于本人最近很忙，所以博客关于VUE的知识要在以后的日子慢慢才会写出来-我会讲关于vue-extend-组件的方法，递归组件，关于vuex在项目中的架构搭建等等知识。希望学无止境。"><a href="#由于本人最近很忙，所以博客关于VUE的知识要在以后的日子慢慢才会写出来-我会讲关于vue-extend-组件的方法，递归组件，关于vuex在项目中的架构搭建等等知识。希望学无止境。" class="headerlink" title="由于本人最近很忙，所以博客关于VUE的知识要在以后的日子慢慢才会写出来 我会讲关于vue.extend()组件的方法，递归组件，关于vuex在项目中的架构搭建等等知识。希望学无止境。"></a>由于本人最近很忙，所以博客关于VUE的知识要在以后的日子慢慢才会写出来 我会讲关于vue.extend()组件的方法，递归组件，关于vuex在项目中的架构搭建等等知识。希望学无止境。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实Vue里，在我们开发中，大多数的东西我们都可以在vue.js的官网里找到。但是也有些 在你封指令或者组件时候。有更便捷的方法，或者可以用高级用法来形容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对于制作滚动代码。JS中offsetTop、clientTop、scrollTop各位置属性详解</title>
    <link href="http://yoursite.com/2018/12/27/JS%E4%B8%ADoffsetTop%E3%80%81clientTop%E3%80%81scrollTop%E3%80%81offsetTop%E5%90%84%E4%BD%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/27/JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解/</id>
    <published>2018-12-27T07:11:06.737Z</published>
    <updated>2018-12-27T07:16:53.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在做自己的一个web端项目（XXX）。 然后在制作滚动代码的时候， 发现自己对offsetTop、clientTop、scrollTop、offsetTop忘记的有点多。。。以前可能对这个操作行云流水的。。。<br>哈哈哈，可能是做的公司Vue项目多， 很少用DOM操作。 突然来做一个滚动代码。。。。。所以，还是得温故而知新</p></blockquote><p>转载：<a href="https://github.com/pramper/Blog/issues/10" target="_blank" rel="noopener">https://github.com/pramper/Blog/issues/10</a></p><p><img src="https://img-blog.csdn.net/20180104085724397" alt=""><br><img src="https://camo.githubusercontent.com/3318530334bbc8f5e7ce267866c43ba72fa01f32/687474703a2f2f6f61376436647871742e626b742e636c6f7564646e2e636f6d2f626c6f672f696d616765732f3038313734323039323736363338392e6a7067" alt=""><br><a id="more"></a></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><strong>offsetTop, offsetLeft</strong>：只读属性。要确定的这两个属性的值，首先得确定元素的offsetParent。<br><strong>offsetParent指的是距该元素最近的position不为static的祖先元素，如果没有则指向body元素</strong>。确定了offsetParent，offsetLeft指的是元素左侧偏移offsetParent的距离，同理offsetTop指的是上侧偏移的距离。<br>offsetHeight, offsetWidth：只读属性。这两个属性返回的是元素的高度或宽度，<strong>包括元素的边框、内边距和滚动条</strong>。返回值是一个经过四舍五入的整数。<strong>（常用来计算为div的总宽度和总高度）</strong></p><p><strong>scrollHeight, scrollWidth</strong>：只读属性。返回元素内容的整体尺寸，<strong>包括元素看不见的部分（需要滚动才能看见的）</strong>。返回值包括padding，但不包括margin和border。如下图：<br><img src="https://camo.githubusercontent.com/7d539d32766b01f59701492d56d2957d83c29d03/687474703a2f2f6f61376436647871742e626b742e636c6f7564646e2e636f6d2f626c6f672f696d616765732f7363726f6c6c4865696768742e706e67" alt=""></p><p>scrollHeight：IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。<br>scrollTop, scrollLeft：图中已经表示的很明白了。如果元素不能被滚动，则为0。<br>clientTop：元素上边框的厚度，当没有指定边框厚底时，一般为0<br>window.innerWidth, window.innerHeight：只读。<strong>视口（viewport）的尺寸，包含滚动条</strong><br>offsetHeight：获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)的高度。IE、Opera 认为 offsetHeight = clientHeight + 滚动条 + 边框。FF 认为 <strong>offsetHeight 是网页内容实际高度</strong>，可以小于 clientHeight。offsetHeight在新版本的FF和IE中是一样的，表示网页的高度，与滚动条无关，chrome中不包括滚动条。<br>clientHeight, clientWidth：<strong>包括padding，但不包括border, margin和滚动条</strong>。如下图：<br><img src="https://camo.githubusercontent.com/e6efea72d00a9e63d840ebb3b00ae61c213992ed/687474703a2f2f6f61376436647871742e626b742e636c6f7564646e2e636f6d2f626c6f672f696d616765732f44696d656e73696f6e732d636c69656e742e706e67" alt=""></p><p>———————————————–分隔线———————————————<br>clientX、clientY：相对于浏览器窗口<strong>可视区域的X，Y坐标（窗口坐标）</strong>，可视区域不包括工具栏和滚动条。<strong>IE事件和标准事件</strong>都定义了这2个属性。<strong>-手指移动的touches.clientY-自动这个属性。 可以来做手指滚动</strong></p><p>pageX、pageY：类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。</p><p>offsetX、offsetY：<strong>相对于事件源元素（target或srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性</strong>。</p><p>screenX、screenY：<strong>相对于用户显示器屏幕左上角的X,Y坐标</strong>。<strong>标准事件和IE事件</strong>都定义了这2个属性</p><p> 常用的是clientX clientY   screenX、screenY</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在做自己的一个web端项目（XXX）。 然后在制作滚动代码的时候， 发现自己对offsetTop、clientTop、scrollTop、offsetTop忘记的有点多。。。以前可能对这个操作行云流水的。。。&lt;br&gt;哈哈哈，可能是做的公司Vue项目多， 很少用DOM操作。 突然来做一个滚动代码。。。。。所以，还是得温故而知新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转载：&lt;a href=&quot;https://github.com/pramper/Blog/issues/10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/pramper/Blog/issues/10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180104085724397&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://camo.githubusercontent.com/3318530334bbc8f5e7ce267866c43ba72fa01f32/687474703a2f2f6f61376436647871742e626b742e636c6f7564646e2e636f6d2f626c6f672f696d616765732f3038313734323039323736363338392e6a7067&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS回收垃圾机制了解</title>
    <link href="http://yoursite.com/2018/12/27/JS%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/27/JS回收垃圾机制了解/</id>
    <published>2018-12-27T07:11:06.736Z</published>
    <updated>2018-12-27T07:14:18.801Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/qq_21325977/article/details/79973761" target="_blank" rel="noopener">https://blog.csdn.net/qq_21325977/article/details/79973761</a><br>最近有同事问我了解关于JS的回收机制不，发现自己没多懂。 所以在网上看了一下介绍。 希望能帮到你们。 我觉的， 了解就好。 不用硬记，这个我们实际开发用的比较少</p><h3 id="了解一下-js-的垃圾回收机制"><a href="#了解一下-js-的垃圾回收机制" class="headerlink" title="了解一下 js 的垃圾回收机制"></a>了解一下 js 的垃圾回收机制</h3><p><strong>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</strong><br><a id="more"></a></p><h4 id="（1）标记清除法"><a href="#（1）标记清除法" class="headerlink" title="（1）标记清除法"></a>（1）标记清除法</h4><p>在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，<strong>原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function</span><br><span class="line">test()&#123; </span><br><span class="line"> var a = 10 ; //被标记 ，进入环境 </span><br><span class="line"> var b = 20 ; //被标记 ，进入环境 </span><br><span class="line">&#125; </span><br><span class="line">test(); //执行完毕 之后 a、b又被标离开环境，被回收</span><br></pre></td></tr></table></figure></p><h4 id="（2）引用计数法"><a href="#（2）引用计数法" class="headerlink" title="（2）引用计数法"></a>（2）引用计数法</h4><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。</p><pre><code>**但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及COM对象，就会存在循环引用的问题**</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function</span><br><span class="line">test()&#123; </span><br><span class="line"> var a = &#123;&#125; ; //a的引用次数为0 </span><br><span class="line"> var b = a ; //a的引用次数加1，为1 </span><br><span class="line"> var c =a; //a的引用次数再加1，为2 </span><br><span class="line"> var b =&#123;&#125;; //a的引用次数减1，为1</span><br></pre></td></tr></table></figure><h3 id="对于内存泄露"><a href="#对于内存泄露" class="headerlink" title="对于内存泄露"></a>对于内存泄露</h3><p>什么情况会引起内存泄漏？<br>虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。</p><ol><li>意外的全局变量引起的内存泄漏。</li></ol><p>原因：全局变量，不会被回收。<br>解决：使用严格模式避免。</p><ol start="2"><li>闭包引起的内存泄漏</li></ol><p>原因：闭包可以维持函数内局部变量，使其得不到释放。<br>解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。</p><ol start="3"><li>没有清理的DOM元素引用</li></ol><p>原因：虽然别的地方删除了，但是对象中还存在对dom的引用<br>解决：手动删除。</p><ol start="4"><li>被遗忘的定时器或者回调</li></ol><p>原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。<br>解决：手动删除定时器和dom。</p><ol start="5"><li>子元素存在引用引起的内存泄漏</li></ol><p>原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。<br>解决：手动删除清空</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/qq_21325977/article/details/79973761&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_21325977/article/details/79973761&lt;/a&gt;&lt;br&gt;最近有同事问我了解关于JS的回收机制不，发现自己没多懂。 所以在网上看了一下介绍。 希望能帮到你们。 我觉的， 了解就好。 不用硬记，这个我们实际开发用的比较少&lt;/p&gt;
&lt;h3 id=&quot;了解一下-js-的垃圾回收机制&quot;&gt;&lt;a href=&quot;#了解一下-js-的垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;了解一下 js 的垃圾回收机制&quot;&gt;&lt;/a&gt;了解一下 js 的垃圾回收机制&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么要前后端分离？各有什么优缺点？</title>
    <link href="http://yoursite.com/2018/12/21/blog8/"/>
    <id>http://yoursite.com/2018/12/21/blog8/</id>
    <published>2018-12-21T06:32:27.031Z</published>
    <updated>2018-12-21T06:56:21.605Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前后分离就是在 架构层次 上 构建项目或对现有的项目 客户端 服务端 分离开，减少前后端代码的耦合度。</p></blockquote><p><img src="../img/blog8_1" alt=""></p><a id="more"></a><h1 id="一、前端"><a href="#一、前端" class="headerlink" title="一、前端"></a>一、前端</h1><p>前后端分离已成为互联网项目开发的业界标准使用方式，通过nginx+tomcat的方式（也可以中间加一个nodejs）有效的进行解耦，并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。这个步骤是系统架构从猿进化成人的必经之路。</p><p>核心思想是前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。</p><p>在互联网架构中，名词解释：</p><p>Web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。</p><p>应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。</p><p><code>一般都是只有web服务器才能被外网访问，应用服务器只能内网访问。</code></p><h1 id="二、术业有专攻（开发人员分离）"><a href="#二、术业有专攻（开发人员分离）" class="headerlink" title="二、术业有专攻（开发人员分离）"></a>二、术业有专攻（开发人员分离）</h1><p>1、对于后端java工程师：</p><p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，java性能优化，以及相关的项目管理等等。</p><p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p><p>2、对于前端工程师：</p><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。</p><p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p><p>术业有专攻，这样你的核心竞争力才会越来越高，正所谓你往生活中投入什么，生活就会反馈给你什么。并且两端的发展都越来越高深，你想什么都会，那你毕竟什么都不精。</p><p>通过将team分成前后端team，让两边的工程师更加专注各自的领域，独立治理，然后构建出一个全栈式的精益求精的team。</p><h1 id="三、原始人时代（各种耦合）"><a href="#三、原始人时代（各种耦合）" class="headerlink" title="三、原始人时代（各种耦合）"></a>三、原始人时代（各种耦合）</h1><p>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。</p><p>大多数项目在java后端都是分了三层，控制层，业务层，持久层。控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。然后jsp页面上使用各种标签或者手写java表达式将后台的数据展现出来，玩的是MVC那套思路。</p><p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器里，对吧？</p><p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p><p>好，下面在浏览器中输入你的网站域名（<a href="http://www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。" target="_blank" rel="noopener">www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）我捡干的说了啊，基础不好的童鞋请自己去搜。</a></p><p>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p><p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p><p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p><p>这就是为什么，越是大中型的web应用，他们越是要解耦。理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p><p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。（注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期哟，亲~）</p><p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？</p><p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。</p><h1 id="四、JSP的痛点"><a href="#四、JSP的痛点" class="headerlink" title="四、JSP的痛点"></a>四、JSP的痛点</h1><p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p><p>1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。一旦服务器出现状况，前后台一起玩完，用户体验极差。</p><p>2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），修改问题时需要双方协同开发，效率低下。</p><p>3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），性能提不上来。</p><p>4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p><p>5、每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。</p><p>6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p><p>7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p><p>8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p><p><code>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！</code></p><p>五、开发模式</p><p>以前老的方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、产品经历/领导/客户提出需求</span><br><span class="line"></span><br><span class="line">2、UI做出设计图</span><br><span class="line"></span><br><span class="line">3、前端工程师做html页面</span><br><span class="line"></span><br><span class="line">4、后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）</span><br><span class="line"></span><br><span class="line">5、集成出现问题</span><br><span class="line"></span><br><span class="line">6、前端返工</span><br><span class="line"></span><br><span class="line">7、后端返工</span><br><span class="line"></span><br><span class="line">8、二次集成</span><br><span class="line"></span><br><span class="line">9、集成成功</span><br><span class="line"></span><br><span class="line">10、交付</span><br></pre></td></tr></table></figure><p>新的方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、产品经历/领导/客户提出需求</span><br><span class="line"></span><br><span class="line">2、UI做出设计图</span><br><span class="line"></span><br><span class="line">3、前后端约定接口&amp;数据&amp;参数</span><br><span class="line"></span><br><span class="line">4、前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）</span><br><span class="line"></span><br><span class="line">5、前后端集成</span><br><span class="line"></span><br><span class="line">6、前端页面调整</span><br><span class="line"></span><br><span class="line">7、集成成功</span><br><span class="line"></span><br><span class="line">8、交付</span><br></pre></td></tr></table></figure><h1 id="六、请求方式"><a href="#六、请求方式" class="headerlink" title="六、请求方式"></a>六、请求方式</h1><p>以前老的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、客户端请求</span><br><span class="line"></span><br><span class="line">2、服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）</span><br><span class="line"></span><br><span class="line">3、调用service,dao代码完成业务逻辑</span><br><span class="line"></span><br><span class="line">4、返回jsp</span><br><span class="line"></span><br><span class="line">5、jsp展现一些动态的代码</span><br></pre></td></tr></table></figure></p><p>新的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器发送请求</span><br><span class="line"></span><br><span class="line">2、直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）</span><br><span class="line"></span><br><span class="line">3、html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）</span><br><span class="line"></span><br><span class="line">4、填充html，展现动态效果，在页面上进行解析并操作DOM。</span><br><span class="line"></span><br><span class="line">总结一下新的方式的请求步骤：</span><br><span class="line"></span><br><span class="line">大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件/数据库/缓存/消息队列服务器集群</span><br><span class="line"></span><br><span class="line">同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</span><br></pre></td></tr></table></figure></p><h1 id="七、前后分离的优势"><a href="#七、前后分离的优势" class="headerlink" title="七、前后分离的优势"></a>七、前后分离的优势</h1><p>1、可以实现真正的前后端解耦，前端服务器使用nginx。前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）</p><p>2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。双方互不干扰，前端与后端是相亲相爱的一家人。</p><p>3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）</p><p>4、减少后端服务器的并发/负载压力。除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。且除了第一次页面请求外，浏览器会大量调用本地缓存。</p><p>5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p><p>6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p><p>7、页面显示的东西再多也不怕，因为是异步加载。</p><p>8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p><p>9、增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p><p>10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p><p>11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用http，性能和安全都有保障。</p><p>12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p><h1 id="八、注意事项"><a href="#八、注意事项" class="headerlink" title="八、注意事项"></a>八、注意事项</h1><p>1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p><p>2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p><p>3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p><p>4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p><p>5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。</p><p>6、 以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p><p>7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p><p>8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p><p>9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。类似于数据校验这种，前后端都需要做！</p><p>10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p><h1 id="九、扩展阅读"><a href="#九、扩展阅读" class="headerlink" title="九、扩展阅读"></a>九、扩展阅读</h1><p>1、其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。</p><p>2、如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p><p>3、如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。JSONP的方式也被淘汰掉了。</p><p>4、如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。</p><p>5、前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。</p><h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了，需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关注点分离</span><br><span class="line">职责分离</span><br><span class="line">对的人做对的事</span><br><span class="line">更好的共建模式</span><br><span class="line">快速的反应变化</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前后分离就是在 架构层次 上 构建项目或对现有的项目 客户端 服务端 分离开，减少前后端代码的耦合度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;../img/blog8_1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>成长的点点滴滴基础</title>
    <link href="http://yoursite.com/2018/12/20/%E6%88%90%E9%95%BF%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/12/20/成长的点点滴滴基础/</id>
    <published>2018-12-20T02:19:41.000Z</published>
    <updated>2018-12-27T07:15:21.994Z</updated>
    
    <content type="html"><![CDATA[<p>最近写多了vue的项目， 之前的JS和CSS和其它知识用的比较少了。 下面的知识是方便回忆的~~~~<br>没啥事记下笔记<br><a id="more"></a><br>JS标准库：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign(这个博主里面还有很多学习资料提供)" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign(这个博主里面还有很多学习资料提供)</a></p><p>2018 啊里的面试题。<br>个人觉得，偶尔看看面试题，不是为了去面试，而是看下面试题，去了解一下深层的概念和知识.<br><a href="https://blog.csdn.net/Carrie_zzz/article/details/80201131" target="_blank" rel="noopener">https://blog.csdn.net/Carrie_zzz/article/details/80201131</a></p><h3 id="get和Post区别"><a href="#get和Post区别" class="headerlink" title="get和Post区别"></a>get和Post区别</h3><p>数据传输：get post的区别<br>重点：GET把参数包含在URL中（数据比较少），POST通过request body传递参数。<br>get的话 就是能获取数据， 但是不能保存。 就是表单那些不能保存<br>Post的话 可以获取数据也能保存。</p><p>另外：<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>GET请求只能进行url编码，而POST支持多种编码方式</p><h3 id="判断一个变量类型是数组还是对象"><a href="#判断一个变量类型是数组还是对象" class="headerlink" title="判断一个变量类型是数组还是对象"></a>判断一个变量类型是数组还是对象</h3><p>1.通过length属性：一般情况下对象没有length属性值，其值为undefiend，而数组的length值为number类型</p><p>　缺点：非常不实用，当对象的属性存在length，且其值为number（比如类数组），则该方法失效，不建议使用，看看即可。<br>2.通过instanceof来判断区分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line"> var obj = &#123;</span><br><span class="line">     name: &apos;lyl&apos;,</span><br><span class="line">     age: 18,</span><br><span class="line">     1: &apos;name&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(arr instanceof Array); //true</span><br><span class="line"> console.log(obj instanceof Array); //false</span><br></pre></td></tr></table></figure></p><p>3.通过constructor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">       var obj = &#123;</span><br><span class="line">           name: &apos;lyl&apos;,</span><br><span class="line">           age: 18,</span><br><span class="line">           1: &apos;name&apos;</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(arr.constructor === Array); //true</span><br><span class="line">       console.log(obj.constructor === Array); //false</span><br></pre></td></tr></table></figure></p><ol start="4"><li><strong>通过toString()方法，数组原型和对象原型定义的toString()方法不同-可以判断任何类型</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　 var arr = [1, 2, 3];</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;lyl&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    1: &apos;name&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.prototype.toString.call(arr) === &apos;[object Array]&apos;); //true</span><br><span class="line">console.log(Object.prototype.toString.call(boj) === &apos;[object Array]&apos;); //false</span><br></pre></td></tr></table></figure></li></ol><p>5.随便找一个数组仅有的方法，来判断数组和对象谁有该方法即可（样例以sort来举例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　　　 var arr = [1, 2, 3];</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;lyl&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    1: &apos;name&apos;</span><br><span class="line">&#125;</span><br><span class="line">　　</span><br><span class="line">console.log(arr.sort === Array.prototype.sort); //true</span><br><span class="line">console.log(obj.sort === Array.prototype.sort); //false</span><br></pre></td></tr></table></figure></p><p> 　<strong>总结：方法应用权重：</strong></p><p>　　　　优先使用方四toString，因为该方法几乎无缺陷。</p><p>　　　　次之可以使用方二instanceof和方三constructor</p><p>　　　　剩下的方法玩玩即可，不实用</p><h3 id="js-和-的区别"><a href="#js-和-的区别" class="headerlink" title="js === 和==的区别"></a>js === 和==的区别</h3><p>==   用于比较   判断 两者相等      ==在比较的时候可以转自动换数据类型<br>===用于严格比较   判断两者严格相等     ===严格比较，不会进行自动转换<br>==会进行隐式类型转换<br>总之： “==” 只要求值相等;   “===” 要求值和类型都相等 </p><h3 id="display中-block-和-inline-和-inline-block区别"><a href="#display中-block-和-inline-和-inline-block区别" class="headerlink" title="display中 block 和 inline 和 inline-block区别"></a>display中 block 和 inline 和 inline-block区别</h3><h4 id="display-block"><a href="#display-block" class="headerlink" title="display:block"></a>display:block</h4><p>block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。<br>block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。<br>block元素可以设置margin和padding属性。</p><h4 id="display-inline"><a href="#display-inline" class="headerlink" title="display:inline"></a>display:inline</h4><p>inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。<br>inline元素设置width,height属性无效。<br>inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</p><h4 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display:inline-block"></a>display:inline-block</h4><p>简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</p><h3 id="Object-assign-方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。–常用"><a href="#Object-assign-方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。–常用" class="headerlink" title="Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。–常用"></a>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。–常用</h3><p>Object.assign(target, …sources) target 目标对象。sources 源对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);</span><br><span class="line"></span><br><span class="line">console.log(object2.c, object2.d);</span><br><span class="line">下面的写法是错的。 </span><br><span class="line">因为...item运算符不能添加进Object.assign.会看做是空。所以穿item</span><br><span class="line"> return this.mallData.mhPicsListStr.map(item =&gt; &#123;</span><br><span class="line"> return Object.assign(&#123;&#125;, ...item, &#123; picsAdd: this.ip+item.picsAdd &#125;); &#125;);</span><br><span class="line">// expected output: 3 5</span><br></pre></td></tr></table></figure></p><p>功能：1.合并对象 2.合并具有相同属性的对象…还有很多<br><strong>该方法属于浅拷贝，当sources源对象发生变化时。新的object中的值也会改变</strong></p><h3 id="Object-prototype-toString-检测数据的数据类型。最好用，最规范的"><a href="#Object-prototype-toString-检测数据的数据类型。最好用，最规范的" class="headerlink" title="Object.prototype.toString(). 检测数据的数据类型。最好用，最规范的"></a>Object.prototype.toString(). 检测数据的数据类型。最好用，最规范的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var toString = Object.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(new Date); // [object Date]</span><br><span class="line">toString.call(new String); // [object String]</span><br><span class="line">toString.call(Math); // [object Math]</span><br><span class="line"></span><br><span class="line">//Since JavaScript 1.8.5</span><br><span class="line">toString.call(undefined); // [object Undefined]</span><br><span class="line">toString.call(null); // [object Null]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var isArray = function (obj) &#123;    // 判断对象是否是数组的标准方法</span><br><span class="line">    return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>返回的值是[object 类型]</strong></p><h3 id="Obj-hasOwnProperty-方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性"><a href="#Obj-hasOwnProperty-方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性" class="headerlink" title="Obj.hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性"></a>Obj.hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性</h3><p>prop  要检测的属性  字符串 名称或者 Symbol。<br>本人常用的是用来检测 prop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">o = new Object();</span><br><span class="line">o.prop = &apos;exists&apos;;</span><br><span class="line"></span><br><span class="line">function changeO() &#123;</span><br><span class="line">  o.newprop = o.prop;</span><br><span class="line">  delete o.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.hasOwnProperty(&apos;prop&apos;);   // 返回 true</span><br><span class="line">changeO();</span><br><span class="line">o.hasOwnProperty(&apos;prop&apos;);   // 返回 false</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong><br>JavaScript 并没有保护 hasOwnProperty 属性名，因此某个对象是有可能存在使用这个属性名的属性，使用外部的 hasOwnProperty 获得正确的结果是需要的：</p><h3 id="把数组降维"><a href="#把数组降维" class="headerlink" title="把数组降维"></a>把数组降维</h3><p>简单的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var res = arr.reduce((beginList,item)=&gt;&#123;</span><br><span class="line">return beginList.concat(item)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure></p><p>但是对于var arr = [1, 2, [3, 4, [5]]]。这样的话。需要用递归方法或者reduce()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">递归</span><br><span class="line">var recursion=function(arr)&#123;</span><br><span class="line">    var len=arr.length,newarr=[];</span><br><span class="line">    for(var i=0;i&lt;len;i++)&#123;      </span><br><span class="line">        if(Array.isArray(arr[i]))</span><br><span class="line">            newarr.push.apply(newarr,recursion(arr[i]))</span><br><span class="line">        else newarr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    return newarr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">更好的方法：reduce</span><br><span class="line">let flatten = arr =&gt; arr.reduce((begin,current)=&gt;&#123;</span><br><span class="line">        Array.isArray(current)?</span><br><span class="line">        begin.push(...flatten(current)):</span><br><span class="line">        begin.push(current);</span><br><span class="line">        return begin</span><br><span class="line">    &#125;,[])</span><br></pre></td></tr></table></figure></p><h3 id="找出数组中出现的次数超过一半以上的选项"><a href="#找出数组中出现的次数超过一半以上的选项" class="headerlink" title="找出数组中出现的次数超过一半以上的选项"></a>找出数组中出现的次数超过一半以上的选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function getItem(arr = []) &#123; </span><br><span class="line">  const half = Math.floor(arr.length / 2) </span><br><span class="line">  let result = [] </span><br><span class="line">  let m = new Map() </span><br><span class="line">  arr.map(item =&gt; &#123; </span><br><span class="line">    m.has(item) ? m.set(item, m.get(item) + 1) : m.set(item, 1) </span><br><span class="line">    if (m.get(item) &gt;= half) &#123; </span><br><span class="line">      !result.includes(item) &amp;&amp; result.push(item) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">  return result.length ? result : 0 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">本人</span><br><span class="line">list.reduce((beginList, item) =&gt; &#123;</span><br><span class="line">if (item in beginList) &#123;</span><br><span class="line">beginList[item] ++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">beginList[item] = 1;</span><br><span class="line">&#125;</span><br><span class="line">return beginList;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">先求出数组的所有内容出现的次数。 然后再循环一次看那个长度超出一半。</span><br></pre></td></tr></table></figure><h3 id="结果返回来true"><a href="#结果返回来true" class="headerlink" title="[]==![]  结果返回来true"></a>[]==![]  结果返回来true</h3><p>==发生js隐式转换。<br>对于JS隐式转换的解释方案。<br><a href="https://juejin.im/post/5bc5c752f265da0a9a399a62" target="_blank" rel="noopener">https://juejin.im/post/5bc5c752f265da0a9a399a62</a></p><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>最简单的就是ES6的语法 new Set();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aca=[&apos;66&apos;,&apos;88&apos;,undefined,NaN,undefined,NaN]</span><br><span class="line">let bbg = new Set(aca)</span><br><span class="line">//Set(4) &#123;&quot;66&quot;, &quot;88&quot;, undefined, NaN&#125;</span><br><span class="line">Array.from(bbg)</span><br><span class="line">//(4) [&quot;66&quot;, &quot;88&quot;, undefined, NaN]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">对象属性去重</span><br><span class="line">function unique(arr)&#123;</span><br><span class="line">　　var res =[];</span><br><span class="line">　　var json = &#123;&#125;;</span><br><span class="line">　　for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">　　　　if(!json[arr[i]])&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　res.push(arr[i]);</span><br><span class="line"></span><br><span class="line">　　　　　　json[arr[i]] = 1;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------reduce---</span><br><span class="line">arr3 = aa =&gt;aa.reduce((begin,items)=&gt;&#123;</span><br><span class="line">if(begin.includes(items))&#123;</span><br><span class="line">begin.push(items)</span><br><span class="line">&#125;</span><br><span class="line">return begin</span><br><span class="line">&#125;,[])</span><br><span class="line">封装诚一个函数</span><br></pre></td></tr></table></figure><blockquote><p>上面indexOf 只能对于字符串有效果。 对于一些数组里面有underfined Object类型的。 indexOf 数组去重不了.所以要用ES6的数组新语法。 includes();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bb=[undefined,&#123;&#125;,&#123;&#125;,Object,undefined]</span><br><span class="line">bb.forEach(item =&gt;&#123;</span><br><span class="line">if(!eray1.includes(item))&#123;</span><br><span class="line">eray1.push(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>但是对于{} 。 includes({})会返回来false.也无法处理。 {}==={}也是会返回来false。<br>处理方式的话 Object.prototype.toString.call({})。做特殊处理。 一般来讲的话。 includes已经够用了</p><p><strong>不用ES6的语法解决</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    function (arr1=[])&#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    var flag = true;  //控制NaN</span><br><span class="line">    for(var i=0;i&lt;arr1.length;i++)&#123;</span><br><span class="line">        if(result.indexOf(arr1[i])==-1)&#123;</span><br><span class="line">            if(this[i]!=this.[i])     //因为IndexOf监控不了NaN值。 需要做一层处理 includes()可以。体验ES6的好处</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(flag)&#123;</span><br><span class="line">                            result.push(arr1[i]);</span><br><span class="line">                            flag = false</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                   result.push(arr1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用过滤器去解决  性能更好</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">   var  r,</span><br><span class="line">arr = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;orange&apos;, &apos;strawberry&apos;];</span><br><span class="line"> r = arr.filter(function (element, index, self) &#123;</span><br><span class="line">     return self.indexOf(element) === index;</span><br><span class="line"> &#125;);</span><br><span class="line">console.log(r.toString());</span><br></pre></td></tr></table></figure><h3 id="小牛第四年会变老，老牛一年生一条小牛。然后第一年买了一条小牛。求N年后多少条"><a href="#小牛第四年会变老，老牛一年生一条小牛。然后第一年买了一条小牛。求N年后多少条" class="headerlink" title="小牛第四年会变老，老牛一年生一条小牛。然后第一年买了一条小牛。求N年后多少条"></a>小牛第四年会变老，老牛一年生一条小牛。然后第一年买了一条小牛。求N年后多少条</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *自己的答案</span><br><span class="line"> *@param &#123;Array&#125; origin -源车间</span><br><span class="line"> *@param &#123;Number&#125; n 年数</span><br><span class="line">*/</span><br><span class="line">function getOrigin(origin,n)&#123;</span><br><span class="line">    const createCatle = cattle =&gt;&#123;</span><br><span class="line">        cattle.age++;</span><br><span class="line">        cattle.age &gt;=4&amp;&amp; origin.push(&#123;age:1&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i=0;i&lt;n;i++)&#123;</span><br><span class="line">        origin.forEach(item=&gt;createCatle(item))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let origin = [&#123;age:1&#125;]</span><br><span class="line">getOrigin(origin,9)</span><br><span class="line">总数等于 origin.length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">网上答案： 斐波那契数列算法</span><br></pre></td></tr></table></figure><h3 id="封装一个函数，参数是定时器的时间，-then执行回调函数"><a href="#封装一个函数，参数是定时器的时间，-then执行回调函数" class="headerlink" title="封装一个函数，参数是定时器的时间，.then执行回调函数"></a>封装一个函数，参数是定时器的时间，.then执行回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function setTimeGo(times)&#123;</span><br><span class="line">return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">resolve();</span><br><span class="line">&#125;,times)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">setTimeGo(2000).then(res=&gt;&#123;</span><br><span class="line">    console.log(&apos;lblblbl&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">//setTimeout是没有回调then的功能。 需要借助new Promise。去实现.then的回调函数</span><br></pre></td></tr></table></figure><h3 id="js-实现-ajax-请求或者submit请求时-锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）"><a href="#js-实现-ajax-请求或者submit请求时-锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）" class="headerlink" title=".js 实现 ajax 请求或者submit请求时 锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）"></a>.js 实现 ajax 请求或者submit请求时 锁屏功能以及开锁功能（请求时界面Loading以及元素不能点击，请求完成即消除Loading）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function(url, fn) &#123;</span><br><span class="line">     var obj = new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据</span><br><span class="line">     obj.open(&apos;GET&apos;, url, true);</span><br><span class="line">     obj.onreadystatechange= function() &#123;</span><br><span class="line">            if(obj.readyState == 4 &amp;&amp; obj.status == 200||obj.status == 304) &#123;</span><br><span class="line"></span><br><span class="line">                   loading.style.display = &quot;none&quot;</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                   alert(&quot;不能点击,哈哈哈!&quot;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br><span class="line">obj.send(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检验对象里面包不包含某个字段-res-hasOwnProperty-‘checkboxState’-indexOf检测数组还有字符串。不能检测字符串"><a href="#检验对象里面包不包含某个字段-res-hasOwnProperty-‘checkboxState’-indexOf检测数组还有字符串。不能检测字符串" class="headerlink" title="检验对象里面包不包含某个字段 res.hasOwnProperty(‘checkboxState’). indexOf检测数组还有字符串。不能检测字符串"></a>检验对象里面包不包含某个字段 res.hasOwnProperty(‘checkboxState’). indexOf检测数组还有字符串。不能检测字符串</h3><p>注意： indexOf是不能检测对象的。 所以不要看经常用就啥用。对于某些同学们<br>      IndexOf 只能检测部分数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gg=[&apos;a&apos;,&apos;b&apos;]</span><br><span class="line">console.log(gg.indexOf(&apos;a&apos;)&gt;&gt;&gt;&gt;&gt;&gt;0)</span><br><span class="line">pp=[&#123;a:22&#125;,&#123;b:33&#125;]</span><br><span class="line">console.log(pp.indexOf(&apos;a) &gt;&gt;&gt;&gt;&gt;&gt;-1)</span><br><span class="line"></span><br><span class="line">除此之外。</span><br><span class="line">对象</span><br><span class="line">const ee = &quot;gg&quot;</span><br><span class="line">pp=&#123;aa:66,cc:&apos;89&apos;&#125;</span><br><span class="line">pp[&apos;aa&apos;]&gt;&gt;&gt;&gt;66.</span><br><span class="line">pp[ee] = 100</span><br><span class="line">pp[&apos;gg&apos;]&gt;&gt;&gt;&gt;&gt;99</span><br><span class="line">数组：</span><br><span class="line">pp[0] = [].对于数组的话。 下标要为数字</span><br></pre></td></tr></table></figure></p><h3 id="overflow-auto-对于一些内容自适应高度的隐藏折叠非常好用。-点击隐藏和显示。"><a href="#overflow-auto-对于一些内容自适应高度的隐藏折叠非常好用。-点击隐藏和显示。" class="headerlink" title="overflow: auto 对于一些内容自适应高度的隐藏折叠非常好用。 点击隐藏和显示。"></a>overflow: auto 对于一些内容自适应高度的隐藏折叠非常好用。 点击隐藏和显示。</h3><p>overflow: scroll将隐藏所有溢出的内容并使滚动条出现在相关元素上。如果内容没有溢出，滚动条仍然可见，但被禁用。<br>overflow: auto 非常相似，但滚动条仅在内容溢出时出现。</p><h3 id="axios-的缺点（ajax-axios-fetch区别）"><a href="#axios-的缺点（ajax-axios-fetch区别）" class="headerlink" title="axios 的缺点（ajax,axios,fetch区别）"></a>axios 的缺点（ajax,axios,fetch区别）</h3><h4 id="1-JQ的ajax"><a href="#1-JQ的ajax" class="headerlink" title="1.JQ的ajax"></a>1.JQ的ajax</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> $.ajax(&#123;</span><br><span class="line">   type: &apos;POST&apos;,</span><br><span class="line">   url: url,</span><br><span class="line">   data: data,</span><br><span class="line">   dataType: dataType,</span><br><span class="line">   success: function () &#123;&#125;,</span><br><span class="line">   error: function () &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 优缺点：<br>本身是针对MVC的编程,不符合现在前端MVVM的浪潮<br>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案<br>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）<br>优点的话：兼容IE的老版本。</p><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    url: &apos;/user/12345&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &apos;Fred&apos;,</span><br><span class="line">        lastName: &apos;Flintstone&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>优缺点：<br>从 node.js 创建 http 请求<br>支持 Promise API<br>客户端支持防止CSRF<br><strong>提供了一些并发请求的接口（重要，方便了很多的操作）</strong></p><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let response = await fetch(url);</span><br><span class="line">  let data = response.json();</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&quot;Oops, error&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：<br>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里<br>更好更方便的写法<br>更加底层，提供的API丰富（request, response）<br>脱离了XHR，是ES规范里新的实现方式<br>缺点<br>1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理<br>2）fetch默认不会带cookie，需要添加配置项<br>3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费<br>4）fetch没有办法原生监测请求的进度，而XHR可以</p><h3 id="为什么要用axios"><a href="#为什么要用axios" class="headerlink" title="为什么要用axios"></a>为什么要用axios</h3><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><p><strong>从浏览器中创建 XMLHttpRequest</strong><br><strong>从 node.js 发出 http 请求</strong><br><strong>支持 Promise API</strong><br><strong>拦截请求和响应</strong><br><strong>转换请求和响应数据</strong><br><strong>取消请求</strong><br><strong>动转换JSON数据</strong><br><strong>客户端支持防止CSRF/XSRF（一些跨域浏览器的伪造请求） 比较安全</strong></p><p>如果真的要说缺点<br>他们浏览器支持有问题。 因为它只支持ie8+以上的。 老版本IE不支持</p><h3 id="什么是跨域，以及解决跨域的实现方式"><a href="#什么是跨域，以及解决跨域的实现方式" class="headerlink" title="什么是跨域，以及解决跨域的实现方式"></a>什么是跨域，以及解决跨域的实现方式</h3><h4 id="有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-39-1-39-b-’2’-c-’’-d-’xxx’-e-undefined-。"><a href="#有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-39-1-39-b-’2’-c-’’-d-’xxx’-e-undefined-。" class="headerlink" title="有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}。"></a>有这样一个URL：<a href="http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:&#39;1&#39;" target="_blank" rel="noopener">http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:&#39;1&#39;</a>, b:’2’, c:’’, d:’xxx’, e:undefined}。</h4><p>一开始自己写的答案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getKeyValue(url)&#123;</span><br><span class="line">const params=&#123;&#125;;</span><br><span class="line">if(url.indexOf(&apos;?&apos;)==-1) return</span><br><span class="line">const urlString = url.substring(url.indexOf(&apos;?&apos;)+1);</span><br><span class="line">urlString.split(&apos;&amp;&apos;).forEach((item)=&gt;&#123;</span><br><span class="line">if(item.indexOf(&apos;=&apos;)&gt;-1)&#123;</span><br><span class="line">let itemParams = item.split(&apos;=&apos;);</span><br><span class="line">params[itemParams[0]] = itemParams[1]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">params[item] = &apos;underfined&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">return params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后面发现 其实split的话。 还是可以优化的。 因为就是就算split判断等号。获得一个数组。就算没有等号。 我赋值一个itemParams[1]。 不存在的话也会为underfined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getKeyValue(url)&#123;</span><br><span class="line">const params=&#123;&#125;;</span><br><span class="line">if(url.indexOf(&apos;?&apos;)==-1) return</span><br><span class="line">const urlString = url.substring(url.indexOf(&apos;?&apos;)+1);</span><br><span class="line">urlString.split(&apos;&amp;&apos;).forEach((item)=&gt;&#123;</span><br><span class="line">let itemParams = item.split(&apos;=&apos;);</span><br><span class="line">params[itemParams[0]] = itemParams[1]</span><br><span class="line">&#125;)</span><br><span class="line">return params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>升级版对于一些如果参数是同名的话。 把他们放在同一个数组里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getMoreKeyValue(url)&#123;</span><br><span class="line"> const params = &#123;&#125;;</span><br><span class="line">if(url.indexOf(&apos;?&apos;)==-1) return</span><br><span class="line">const urlString = url.substring(url.indexOf(&apos;?&apos;)+1);</span><br><span class="line">urlString.split(&apos;&amp;&apos;).forEach(item=&gt;&#123;</span><br><span class="line">let itemParams = item.split(&apos;=&apos;);</span><br><span class="line">if(params.hasOwnProperty(itemParams[0]))&#123;</span><br><span class="line">params[itemParams[0]]=Array.isArray(itemParams[0])?params[itemParams[0]].push(itemParams[1]) :[params[itemParams[0]],itemParams[1]]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">params[itemParams[0]] = itemParams[1]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">return params</span><br><span class="line">&#125;</span><br><span class="line">url = &apos;http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2&apos;;</span><br><span class="line">getMoreKeyValue(url) &gt;&gt;&gt;&gt;c &#123; a: [ &apos;1&apos;, &apos;2&apos; ], b: &apos;2&apos;, c: &apos;&apos;, d: &apos;xxx&apos;, e: undefined &#125;</span><br></pre></td></tr></table></figure></p><h3 id="经常问的红绿灯问题"><a href="#经常问的红绿灯问题" class="headerlink" title="经常问的红绿灯问题"></a>经常问的红绿灯问题</h3><p>简单版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(changered,0);    /*设置最开始时间间隔为0*/</span><br><span class="line"> function changered()&#123;</span><br><span class="line">     var div=document.getElementById(&quot;div1&quot;);</span><br><span class="line">     div.style.backgroundColor=&quot;red&quot;;</span><br><span class="line">     console.log(&apos;红&apos;)</span><br><span class="line">     setTimeout(changeyellow,7000);/*红灯持续亮7秒*/</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> function changeyellow()&#123;</span><br><span class="line">     var div=document.getElementById(&quot;div1&quot;);</span><br><span class="line">     div.style.backgroundColor=&quot;yellow&quot;;</span><br><span class="line">     console.log(&apos;黄&apos;)</span><br><span class="line">     setTimeout(changegreen,3000);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> function changegreen()&#123;</span><br><span class="line">     console.log(&apos;绿&apos;)</span><br><span class="line">     var div=document.getElementById(&quot;div1&quot;);</span><br><span class="line">     div.style.backgroundColor=&quot;green&quot;;</span><br><span class="line">     setTimeout(changered,5000);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>对于一些需要要.then函数去做红绿等的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//创建一个打印的函数</span><br><span class="line">function light(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;</span><br><span class="line">//封装一个setTimeout的函数</span><br><span class="line">function getSetTimeOut(time)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;,time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//执行红绿灯函数</span><br><span class="line">async function begin()&#123;</span><br><span class="line">await getSetTimeOut(7000).then(console.log(&apos;红&apos;))</span><br><span class="line">await getSetTimeOut(5000).then(console.log(&apos;黄&apos;))</span><br><span class="line">await getSetTimeOut(3000).then(console.log(&apos;绿&apos;))</span><br><span class="line">begin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="两个数组做比较。-当有一个相等的话。-跳出循环。运行次数最少-自己项目的做法"><a href="#两个数组做比较。-当有一个相等的话。-跳出循环。运行次数最少-自己项目的做法" class="headerlink" title="两个数组做比较。 当有一个相等的话。 跳出循环。运行次数最少-自己项目的做法"></a>两个数组做比较。 当有一个相等的话。 跳出循环。运行次数最少-自己项目的做法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">array2 = [&apos;66&apos;,&apos;77,&apos;,&apos;99&apos;];</span><br><span class="line">array = [&apos;55&apos;,&apos;66&apos;,&apos;555&apos;,&apos;44&apos;];</span><br><span class="line">for(let i = 0;i&lt;array2.length;i++)&#123;</span><br><span class="line">bol = array.some(item=&gt;&#123;</span><br><span class="line">console.log(&apos;22&apos;);</span><br><span class="line">return item===array2[i]</span><br><span class="line">&#125;)</span><br><span class="line">  if(bol) break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一个数字和数组做比较</span><br><span class="line">bol = array.some(item=&gt;&#123;</span><br><span class="line">console.log(22)</span><br><span class="line">return item===b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.bankNbr = res.BANK_NBR;</span><br><span class="line"> this.subBranchList = res.subBranchList;</span><br><span class="line">    if (this.bankNbr != &apos;&apos;) &#123;</span><br><span class="line">    this.isMatchSales = this.salesBranch.some(item =&gt; &#123;</span><br><span class="line">    return item.brano === this.bankNbr;</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         for (let i = 0; i &lt; this.subBranchList.length; i++) &#123;</span><br><span class="line">        this.isMatchSales = this.salesBranch.some(item =&gt; &#123;</span><br><span class="line">            return item.brano === this.subBranchList[i].subBranchNo;</span><br><span class="line">                &#125;);</span><br><span class="line">                if (this.isMatchSales) break;</span><br><span class="line">                     &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>减少对于for循环的使用。 用ES6的语法 find()。 取代for循环啊</p><blockquote><p>find()。数组实例的方法。参数是一个回调函数。所有数组依次执行回调函数，直到找出一个返回值为<strong>true</strong>的成员。然后返回该成员。如果没有符合条件的成员，返回underfined.<br>优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const matchitem = this.subBranchList.find(sub =&gt;this.salesBranch.some(item =&gt; &#123;item.brano === usb.subBranchNo;&#125;););一行解决</span><br><span class="line">this.isMatchSales = !!matchitem  //转义成boolean类型  !underfined =true !!=false   返回来item的话。就会这样</span><br><span class="line">Object.is(NAN,value)  //查看数据类型为NAN的。 用find</span><br></pre></td></tr></table></figure></p></blockquote><p>用find的话 如果Item返回来是空字符类型的话，!!也会转化为false。 对于有空类型的话’’。用findIndex()比较好，返回来index索引.再去转boolean 比较好。<br>对于find和findindex 当item返回来true的时候，都会跳出循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const matchitem = this.subBranchList.findIndex(sub =&gt;this.salesBranch.some(item =&gt; &#123;item.brano === usb.subBranchNo;&#125;););一行解决</span><br><span class="line">this.isMatchSales = matchitem !==-1  //转义成boolean类型  findIndex相当于indexOf类似。 找不到的话， 会返回来索引-1</span><br></pre></td></tr></table></figure></p><h3 id="对于数组的相邻去重。-还有相邻相加-同事出题"><a href="#对于数组的相邻去重。-还有相邻相加-同事出题" class="headerlink" title="对于数组的相邻去重。 还有相邻相加- 同事出题"></a>对于数组的相邻去重。 还有相邻相加- 同事出题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">数组相邻去重</span><br><span class="line">bb = &apos;AAAAAAbbbbbbaaaaacccc&apos;</span><br><span class="line">bgg=[&apos;1&apos;,&apos;2&apos;,&apos;2&apos;,&apos;3&apos;,&apos;2&apos;]</span><br><span class="line">        function getArray(params)&#123;</span><br><span class="line">            const result = [];</span><br><span class="line">             for(let i=0;i&lt;params.length;i++)&#123;</span><br><span class="line">               if(i==0 ||params[i-1] !==params[i])&#123;</span><br><span class="line">                   result.push(params[i])</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return result</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">console.log(getArray(bb)) //[&quot;A&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;]</span><br><span class="line">console.log(getArray(bgg)) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">数组相邻相加</span><br><span class="line">bg=[&apos;1&apos;,&apos;4&apos;,&apos;4&apos;,&apos;4&apos;,&apos;2&apos;,&apos;3&apos;,&apos;3&apos;]</span><br><span class="line">function getArray2(params)&#123;</span><br><span class="line">            const result = [];</span><br><span class="line">             for(let i=0;i&lt;params.length;i++)&#123;</span><br><span class="line">                if(params[i-1] !==params[i])&#123;</span><br><span class="line">                   result.push(params[i])</span><br><span class="line">                   &#125;else if(params[i-1] ===params[i])&#123;</span><br><span class="line">const len = result.length;</span><br><span class="line">result[len-1] = (Number(result[len-1])+Number(params[i])).toString();</span><br><span class="line">&#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return result</span><br><span class="line">           &#125;</span><br><span class="line">console.log(getArray2(bg)) //[&quot;1&quot;, &quot;12&quot;, &quot;2&quot;, &quot;6&quot;]</span><br></pre></td></tr></table></figure><h3 id="bb-’aAbCdE’-打印-“A-Aa-Bbb-Cccc-Ddddd-Eeeeee”"><a href="#bb-’aAbCdE’-打印-“A-Aa-Bbb-Cccc-Ddddd-Eeeeee”" class="headerlink" title="bb=’aAbCdE’ 打印 “A-Aa-Bbb-Cccc-Ddddd-Eeeeee”"></a>bb=’aAbCdE’ 打印 “A-Aa-Bbb-Cccc-Ddddd-Eeeeee”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">自己的思路</span><br><span class="line">function getArr2(strs)&#123;</span><br><span class="line">let allStr = &apos;&apos;;</span><br><span class="line">const creatDo = (case1,n)=&gt;&#123;</span><br><span class="line">let casestr1=&apos;&apos;;</span><br><span class="line">casestr1 = case1.toUpperCase()+case1.toLowerCase().repeat(n);</span><br><span class="line">return casestr1</span><br><span class="line">&#125;</span><br><span class="line">for(let j=0;j&lt;strs.length;j++)&#123;</span><br><span class="line">allStr = j==0?creatDo(strs[j],j):allStr+&apos;-&apos;+creatDo(strs[j],j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return allStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES7</span><br><span class="line">function func4(str) &#123;</span><br><span class="line">  return str</span><br><span class="line">    .split(&apos;&apos;)</span><br><span class="line">    .map((en, i) =&gt; en.toUpperCase().padEnd(i + 1, en.toLowerCase()))  //获得一个新数组。.padEnd(n,test) 代表在后面加N个test</span><br><span class="line">    .join(&apos;-&apos;)  //数组的并接</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES6</span><br><span class="line">function fun5(str)&#123;</span><br><span class="line">    return str</span><br><span class="line">    .split(&apos;&apos;)</span><br><span class="line">    .map((item,i)=&gt;`$&#123;item.toUpperCase()&#125;$&#123;item.toLowerCase().repeat(i)&#125;`)</span><br><span class="line">    .join(&apos;-&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传入10-求出10里面（不包括10）-3-5-倍数相加之和-例如-3-6-9-5（3的倍数）（5的倍数）-3-6-9-5-23"><a href="#传入10-求出10里面（不包括10）-3-5-倍数相加之和-例如-3-6-9-5（3的倍数）（5的倍数）-3-6-9-5-23" class="headerlink" title="传入10  求出10里面（不包括10） 3 5 倍数相加之和 例如 3 6 9 5（3的倍数）（5的倍数） 3+6+9+5 = 23"></a>传入10  求出10里面（不包括10） 3 5 倍数相加之和 例如 3 6 9 5（3的倍数）（5的倍数） 3+6+9+5 = 23</h3><p>其实用循环是不可以的。所以啊  等差数列求和  等差求和算法 直接运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function totol(nums)&#123;</span><br><span class="line">    let sum=0;</span><br><span class="line">    for(let i=0;i&lt;nums;i++)&#123;</span><br><span class="line">        if(i%3==0||i%5==0)&#123;</span><br><span class="line">            sum +=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">自己写的</span><br><span class="line">function totol(nums)&#123;</span><br><span class="line">let sum=0;</span><br><span class="line">let threeCount=1;</span><br><span class="line">let fiveCount=1;</span><br><span class="line">for(let i=3;i&lt;nums;i=3*threeCount)&#123;</span><br><span class="line">sum+=i;</span><br><span class="line">++threeCount;</span><br><span class="line">console.log(threeCount)</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">for(let j=5;j&lt;nums;j=5*fiveCount)&#123;</span><br><span class="line">sum+=j;</span><br><span class="line">fiveCount++;</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优化后</span><br><span class="line">function fucc(num)&#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    for(let i=1;i*3&lt;num;i++)&#123;</span><br><span class="line">        if(i*5&lt;num) result +=i*5</span><br><span class="line">        result +=i*3</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断回文数"><a href="#判断回文数" class="headerlink" title="判断回文数"></a>判断回文数</h3><p>利用数组反序号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isPalindrome(str)&#123;</span><br><span class="line">    return str.split(&apos;&apos;).reverse().join(&apos;&apos;) ===str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写多了vue的项目， 之前的JS和CSS和其它知识用的比较少了。 下面的知识是方便回忆的~~~~&lt;br&gt;没啥事记下笔记&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域？？？跨域！！！</title>
    <link href="http://yoursite.com/2018/12/20/blog7/"/>
    <id>http://yoursite.com/2018/12/20/blog7/</id>
    <published>2018-12-20T01:58:03.101Z</published>
    <updated>2018-12-20T02:48:58.592Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>身为前端，常遭遇面试题，何为跨域？为何跨域？怎样跨域？一连串的问题扑面而来，背过面试题的肯定就暗自窃喜，没背过的心里一阵阴凉。。。</p></blockquote><h1 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h1><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。</p><p>因为浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了。</p><a id="more"></a><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同.</p><p>比如:我在本地上的域名是study.cn,请求另外一个域名一段数据</p><p><img src="../img/blog7_1.png" alt=""></p><p>这个时候在浏览器上会报错:</p><p><img src="../img/blog7_2.png" alt=""></p><p>这个就是同源策略的保护,如果浏览器对javascript没有同源策略的保护,那么一些重要的机密网站将会很危险~</p><table><thead><tr><th>请求地址</th><th style="text-align:right">形式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td><a href="http://study.cn/test/a.html" target="_blank" rel="noopener">http://study.cn/test/a.html</a></td><td style="text-align:right">同一域名,不同文件夹</td><td style="text-align:center">成功</td></tr><tr><td><a href="http://study.cn/json/jsonp/jsonp.html" target="_blank" rel="noopener">http://study.cn/json/jsonp/jsonp.html</a></td><td style="text-align:right">同一域名,统一文件夹</td><td style="text-align:center">成功</td></tr><tr><td><a href="http://a.study.cn/json/jsonp/jsonp.html" target="_blank" rel="noopener">http://a.study.cn/json/jsonp/jsonp.html</a></td><td style="text-align:right">不同域名,文件路径相同</td><td style="text-align:center">失败</td></tr><tr><td><a href="http://study.cn:8080/json/jsonp/jsonp.html" target="_blank" rel="noopener">http://study.cn:8080/json/jsonp/jsonp.html</a></td><td style="text-align:right">同一域名,不同端口</td><td style="text-align:center">失败</td></tr><tr><td><a href="https://study.cn/json/jsonp/jsonp.html" target="_blank" rel="noopener">https://study.cn/json/jsonp/jsonp.html</a></td><td style="text-align:right">同一域名,不同协议　</td><td style="text-align:center">失败</td></tr></tbody></table><h1 id="怎样跨域"><a href="#怎样跨域" class="headerlink" title="怎样跨域"></a>怎样跨域</h1><ol><li>通过jsonp跨域</li><li>document.domain + iframe跨域</li><li>location.hash + iframe</li><li>window.name + iframe跨域</li><li>postMessage跨域</li><li>跨域资源共享（CORS）</li><li>nginx代理跨域</li><li>nodejs中间件代理跨域</li><li>WebSocket协议跨域</li></ol><h2 id="一、通过jsonp跨域"><a href="#一、通过jsonp跨域" class="headerlink" title="一、通过jsonp跨域"></a>一、通过jsonp跨域</h2><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p>a.原生实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">    script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 传参并指定回调执行函数为onBack</span></span></span><br><span class="line"><span class="javascript">    script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="built_in">JSON</span>.stringify(res));</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务端返回如下（返回时即执行全局函数）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onBack(&#123;<span class="string">"status"</span>: <span class="literal">true</span>, <span class="string">"user"</span>: <span class="string">"admin"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>b.jquery ajax：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://www.domain2.com:8080/login'</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    jsonpCallback: <span class="string">"onBack"</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>c.vue.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(<span class="string">'http://www.domain2.com:8080/login'</span>, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">'onBack'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>后端node.js代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><p>jsonp缺点：只能实现get一种请求</p><h2 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a>二、 document.domain + iframe跨域</h2><p>此方案仅限主域相同，子域不同的跨域应用场景。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>a.父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">www.domain.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://child.domain.com/b.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = <span class="string">'admin'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b.子窗口：(child.domain.com/b.html)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取父窗口中变量</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">'get js data from parent ---&gt; '</span> + <span class="built_in">window</span>.parent.user);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a>三、 location.hash + iframe跨域</h2><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>a. a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">www.domain1.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.domain2.com/b.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 向b.html传hash值</span></span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        iframe.src = iframe.src + <span class="string">'#user=admin'</span>;</span></span><br><span class="line"><span class="undefined">    &#125;, 1000);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 开放给同域c.html的回调方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">onCallback</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from c.html ---&gt; '</span> + res);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b. b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span><span class="attr">src</span>=<span class="string">"http://www.domain1.com/c.html"</span><span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        iframe.src = iframe.src + location.hash;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>c. c.html：(<a href="http://www.domain1.com/c.html" target="_blank" rel="noopener">www.domain1.com/c.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听b.html传来的hash值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">'hello: '</span> + location.hash.replace(<span class="string">'#user='</span>, <span class="string">''</span>));</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a>四、 window.name + iframe跨域</h2><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>a. a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">www.domain1.com/a.html</a>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> proxy = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载跨域页面</span></span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">            iframe.contentWindow.location = <span class="string">'http://www.domain1.com/proxy.html'</span>;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destoryFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        iframe.contentWindow.document.write(<span class="string">''</span>);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求跨域b页面数据</span></span><br><span class="line">    proxy(<span class="string">'http://www.domain2.com/b.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        alert(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>b. proxy.html：(<a href="http://www.domain1.com/proxy..." target="_blank" rel="noopener">www.domain1.com/proxy...</a>.</p><p>中间代理页，与a.html同域，内容为空即可。</p><p>c. b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'This is domain2 data!'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h2 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a>五、 postMessage跨域</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p><p>a. a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">www.domain1.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.domain2.com/b.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">       </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            name: <span class="string">'aym'</span></span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 向domain2传送跨域数据</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain2.com'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from domain2 ---&gt; '</span> + e.data);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b. b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from domain1 ---&gt; '</span> + e.data);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (data) &#123;</span></span><br><span class="line"><span class="undefined">            data.number = 16;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain1.com'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a>六、 跨域资源共享（CORS）</h2><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。<br>带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。<br>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><p>1、 前端设置：</p><p>1.）原生ajax</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.domain2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.）jQuery ajax</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">xhrFields: &#123;</span><br><span class="line">    withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">&#125;,</span><br><span class="line">crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.）vue框架在vue-resource封装的ajax组件中加入以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>2、 服务端设置：<br>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>1.）Java后台：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment">* 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>);  <span class="comment">// 若有端口需写全（协议+域名+端口）</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure></p><p>2.）Nodejs后台示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><h2 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a>七、 nginx代理跨域</h2><p>1、 nginx配置解决iconfont跨域</p><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><p>location / {<br>  add_header Access-Control-Allow-Origin *;<br>}</p><p>2、 nginx反向代理接口跨域</p><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#proxy服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin http://www.domain1.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.) 前端代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>2.) Nodejs后台示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><h2 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a>八、 Nodejs中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。</p><p>1、 非vue框架的跨域（2次跨域）</p><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><p>1.）前端代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问http-proxy-middleware代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:3000/login?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>2.）中间件服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    target: <span class="string">'http://www.domain2.com:8080'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    onProxyRes: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://www.domain1.com'</span>);</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Proxy server is listen at port 3000...'</span>);</span><br></pre></td></tr></table></figure><p>3.）Nodejs后台同（六：nginx）</p><p>2、 vue框架的跨域（1次跨域）</p><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: <span class="string">'/login'</span>,</span><br><span class="line">            target: <span class="string">'http://www.domain2.com:8080'</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.）前端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">        socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'data from server: ---&gt; '</span> + msg); </span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">        socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'Server socket has closed.'</span>); </span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        socket.send(<span class="keyword">this</span>.value);</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.）Nodejs socket后台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">'hello：'</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data from client: ---&gt; '</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Client socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>参考链接：<a href="http://www.cnblogs.com/roam/p/7520433.html" target="_blank" rel="noopener">http://www.cnblogs.com/roam/p/7520433.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;身为前端，常遭遇面试题，何为跨域？为何跨域？怎样跨域？一连串的问题扑面而来，背过面试题的肯定就暗自窃喜，没背过的心里一阵阴凉。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;何为跨域&quot;&gt;&lt;a href=&quot;#何为跨域&quot; class=&quot;headerlink&quot; title=&quot;何为跨域&quot;&gt;&lt;/a&gt;何为跨域&lt;/h1&gt;&lt;p&gt;浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。&lt;/p&gt;
&lt;p&gt;因为浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了。&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js如何判断数组是数组？</title>
    <link href="http://yoursite.com/2018/12/13/blog6/"/>
    <id>http://yoursite.com/2018/12/13/blog6/</id>
    <published>2018-12-13T02:07:22.234Z</published>
    <updated>2018-12-13T03:01:04.577Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题表面看起来好像很容易，其实暗藏玄机。就像别人问你，你是如何证明你是你？（听着想打人了吧，哈哈哈）</p><p>下来就来验证一下如何判断数组是数组。</p><blockquote><p>JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法.</p></blockquote><a id="more"></a><h1 id="运用typeof运算符来判断"><a href="#运用typeof运算符来判断" class="headerlink" title="运用typeof运算符来判断"></a>运用typeof运算符来判断</h1><p>先来看看一张包含typeof运算法的针对不同参数的输出结果的表格：</p><p><img src="../img/js_shuzu.png" alt=""></p><p>再来看看用typeof是否能判断出数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> c= [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)); <span class="comment">//Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(b)); <span class="comment">//Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(c)); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure><p>发现了吧，数组被归到了Any other object当中,并没有办法区分数组，对象，null等原型链上都有Object的数据类型。因此，在JavaScript项目中用typeof来判断一个位置类型的数据是否为数组，是非常不靠谱的。</p><h1 id="用instanceof判断"><a href="#用instanceof判断" class="headerlink" title="用instanceof判断"></a>用instanceof判断</h1><p>instanceof运算符可以用来判断某个构造函数的prototype属性所指向的對象是否存在于另外一个要检测对象的原型链上。在使用的时候语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure><p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true,在数组的原型链上也能找到Object构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>由上面的几行代码可以看出，使用instanceof运算符可以分辨数组和对象，可以判断数组是数组。</p><p>但是这不是精确的</p><p>我们用一段伪代码来模拟其内部执行过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> (A,B) = &#123;</span><br><span class="line">    <span class="keyword">var</span> L = A.__proto__;</span><br><span class="line">    <span class="keyword">var</span> R = B.prototype;</span><br><span class="line">    <span class="keyword">if</span>(L === R) &#123;</span><br><span class="line">        <span class="comment">//A的内部属性__proto__指向B的原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述过程可以看出，当 A 的 <strong>proto</strong> 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;</span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> Person <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们发现，虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？</p><p>我们来分析一下 [ ]、Array、Object 三者之间的关系：</p><p>从 instanceof 能够判断出 [ ].proto 指向 Array.prototype，而 Array.prototype.proto 又指向了Object.prototype，最终 Object.prototype.proto 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：</p><p><img src="../img/blog6_poto.png" alt=""></p><p>从原型链可以看出，[] 的 proto 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p><p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p><p>为了解决这个问题， ECMAScript 5 新增了 Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p><h1 id="用Array对象的isArray方法判断"><a href="#用Array对象的isArray方法判断" class="headerlink" title="用Array对象的isArray方法判断"></a>用Array对象的isArray方法判断</h1><p>当参数为数组的时候，isArray方法返回true，当参数不为数组的时候，isArray方法返回false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.isArray(a);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>它与instance运算符判断的方法以及Object.prototype.toString法并不相同，一些列的修改并不会影响到判断的结果。</p><p>Array.isArray是ES5标准中增加的方法，部分比较老的浏览器可能会有兼容问题。</p><h1 id="用constructor判断"><a href="#用constructor判断" class="headerlink" title="用constructor判断"></a>用constructor判断</h1><p>实例化的数组拥有一个constructor属性，这个属性指向生成这个数组的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor);<span class="comment">//function Array()&#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>以上的代码说明，数组是有一个叫Array的函数实例化的。<br>如果被判断的对象是其他的数据类型的话，结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor);<span class="comment">//function Object()&#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="regexp">/^[0-9]$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(r.constructor);<span class="comment">//function RegExp() &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n.constructor);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>看到这里，你可能会觉得这也是一种靠谱的判断数组的方法，我们可以用以下的方式来判断:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor == <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>但是，很遗憾的通知你，constructor属性是可以改写的，如果你一不小心作死改了constructor属性的话，那么使用这种方法就无法判断出数组的真是身份了，写到这里，我不禁想起了无间道的那段经典对白，梁朝伟：“对不起，我是警察。”刘德华：“谁知道呢？”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个数组</span></span><br><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line"><span class="comment">//作死将constructor属性改成了别的</span></span><br><span class="line">a.contrtuctor = <span class="built_in">Object</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor == <span class="built_in">Array</span>);<span class="comment">//false (哭脸)</span></span><br><span class="line"><span class="built_in">console</span>.log(a.constructor == <span class="built_in">Object</span>);<span class="comment">//true (哭脸)</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">//true (instanceof火眼金睛)</span></span><br></pre></td></tr></table></figure><p>可以看出，constructor属性被修改之后，就无法用这个方法判断数组是数组了，除非你能保证不会发生constructor属性被改写的情况，否则用这种方法来判断数组也是不靠谱的。</p><h1 id="用Object的toString方法判断"><a href="#用Object的toString方法判断" class="headerlink" title="用Object的toString方法判断"></a>用Object的toString方法判断</h1><blockquote><p>根据对象的class属性(类属性)，跨原型链调用toString()方法。</p></blockquote><p>在js中一个对象一旦被创建，在内部会携带创建对象的类型名，一旦创建就不能被修改了,每一个继承自Object的对象都拥有toString的方法。</p><p>如果一个对象的toString方法没有被重写过的话，那么toString方法将会返回”[object type]”，其中的type代表的是对象的类型，根据type的值，我们就可以判断这个疑似数组的对象到底是不是数组了。</p><p>你可能会纠结，为什么不是直接调用数组，或则字符串自己的的toString方法呢？我们试一试就知道了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'Hello'</span>,<span class="string">'Howard'</span>];</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="number">0</span>:<span class="string">'Hello'</span>,<span class="number">1</span>:<span class="string">'Howard'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c = <span class="string">'Hello Howard'</span>;</span><br><span class="line">a.toString();<span class="comment">//"Hello,Howard"</span></span><br><span class="line">b.toString();<span class="comment">//"[object Object]"</span></span><br><span class="line">c.toString();<span class="comment">//"Hello,Howard"</span></span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，除了对象之外，其他的数据类型的toString返回的都是内容的字符串，只有对象的toString方法会返回对象的类型。所以要判断除了对象之外的数据的数据类型，我们需要“借用”对象的toString方法，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'Hello'</span>,<span class="string">'Howard'</span>];</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="number">0</span>:<span class="string">'Hello'</span>,<span class="number">1</span>:<span class="string">'Howard'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> c = <span class="string">'Hello Howard'</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a);<span class="comment">//"[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(b);<span class="comment">//"[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(c);<span class="comment">//"[object String]"</span></span><br></pre></td></tr></table></figure><p>使用apply方法也能达到同样的效果</p><p>总的来看，用es5的isArray以及toString方法是最为靠谱的，其他就不建议拿来用了。</p><p>你是不是你，看完有结果了吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个问题表面看起来好像很容易，其实暗藏玄机。就像别人问你，你是如何证明你是你？（听着想打人了吧，哈哈哈）&lt;/p&gt;
&lt;p&gt;下来就来验证一下如何判断数组是数组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript有五种方法可以确定一个值到底是什么类型，分别是typeof运算符，constructor法，instanceof运算符，Object.prototype.toString方法以及Array.isArray法.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Vuex原理</title>
    <link href="http://yoursite.com/2018/12/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Vuex%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/13/深入了解Vuex原理/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-27T07:15:25.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近有个同事问了我很多关于vuex的原理和知识。 突然发现，好像最近做公司的项目，（项目原因，要自己在vue中封一个方法。例如localStorage.或者sessiontStorage） 好久没用vuex了。 都是用公司大佬封装的存储数据的方法~~~~。<br>但是对于我们这些刚刚出去工作的人，或者在一些Vue项目的公司工作的话。 理解vuex原理是必不可少的。 那么接下来 想着分享vuex的原理。顺便帮自己复习一下。<br><a id="more"></a><br>转载：<a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh/guide/</a>  —vuex官网。<br>如果你们觉的看官网更容易理解。 可以看官网。 我是按照自己更容易理解的方法。根据VUEX做一次笔记。 欢迎给意见。</p></blockquote><h2 id="介绍VUEX"><a href="#介绍VUEX" class="headerlink" title="介绍VUEX"></a>介绍VUEX</h2><p>Vuex是Vue.js应用程序的<strong>状态管理模式+库</strong>.它充当应用程序中<strong>所有组件</strong>的<strong>集中存储</strong>，其规则确保state只能以可预测的方式进行变更。它还与Vue的官方devtools扩展集成，以提供零配置时间旅行调试和<strong>状态快照导出/导入等高级功能</strong>。</p><p>State状态，这是真理，推动我们的<strong>应用程序的来源</strong>;<br>View视图，这是仅仅一个声明性映射<strong>状态</strong> ;<br>Actions动作是状态可能因<strong>视图中的用户输入而改变的方式</strong>。</p><p>为什么要用vuex呢？<br>Vue 属于一个单向数据流的程序。 -简单性<br>但是，当我们有多个<strong>共享共同状态的组件</strong>时。 这种简单性就会崩溃</p><p>多个视图可能取决于<strong>同一个状态</strong>。<br>不同观点的Actions可能需要改变同一个state。</p><blockquote><p>对于问题一，对于深层嵌套组件，传递Data可能很乏味，而且对于兄弟组件根本不起作用。对于问题二，我们经常发现自己采用解决方案，例如到达直接父/子实例引用或尝试通过事件变异和同步状态的多个副本。这两种模式都很脆弱，很快导致无法维护的代码。</p></blockquote><p>所以这个时候，就需要引入到了<strong>VUEX</strong>,从组件中提供共享的state（状态）。而且在<strong>全局</strong>中去管理他们。 有了这个。 才可以让组件树变成一个更大的视图。<strong>任何组件</strong>都可以访问state状态或者触发动作Actions。无论他们在哪个树<br>原理图.<br>Devtools属于Vue官方扩展集成的工具<br><!-- ![](https://vuex.vuejs.org/vuex.png) --></p><h3 id="Vuex核心"><a href="#Vuex核心" class="headerlink" title="Vuex核心"></a>Vuex核心</h3><p>State Getters Mutations Actions Modules</p><p>VUEX入门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//安装vuex</span><br><span class="line">npm install vuex --save</span><br><span class="line">//在自己的src创建一个store目录。创建文件 index.js .然后引入Vuex</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    city:&apos;上海&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">    changePatch(ctx,city)&#123;</span><br><span class="line">      ctx.changeCity(&apos;city&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    changeCity(state,city)&#123;</span><br><span class="line">      state.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//在main.js引用</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  store,</span><br><span class="line">&#125;)</span><br><span class="line">// 在组件里面引用---最直接的引用</span><br><span class="line">    &lt;div class=&quot;button&quot;&gt;&#123;&#123;this.$store.state.city&#125;&#125;&lt;/div&gt;</span><br><span class="line">//对于上图的引用 vuex里面主要是通过state actions mutations来操作流程的。</span><br><span class="line">//当组件想修改state的数据的话。 mutations是唯一的方式。 所以要通过dispatch去修改actions。 再通过actions去修改Mutations。mutations再去修改state的值。 从而改变各个组件依赖这个state的值</span><br><span class="line"></span><br><span class="line">vue</span><br><span class="line">&lt;div class=&quot;button&quot; @click=&quot;handleCityChange(item.name)&quot;&gt;&#123;item.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">JS</span><br><span class="line"> handleCityChange(cityName)&#123;</span><br><span class="line">    this.$store.dispatch(&apos;changePatch&apos;,cityName)</span><br><span class="line"> &#125;</span><br><span class="line"> store.js</span><br><span class="line"> 如上方</span><br></pre></td></tr></table></figure><p>其实上方的图是对于VUEX最原始的用法。<br><strong>但是 我们我们组件里传递的数据。 如果不是异步的话。 我们是可以直接去改变mutations。去修改的state的值。 一样是可以的</strong></p><p><strong>VUEX应用的核心是store库</strong><br>Vuex 的状态存储是<strong>响应式</strong>的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到<strong>高效更新</strong>。</p><p>你不能直接改变 store 中的状态。改变 store 中的状态的<strong>唯一途径就是显式地提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近有个同事问了我很多关于vuex的原理和知识。 突然发现，好像最近做公司的项目，（项目原因，要自己在vue中封一个方法。例如localStorage.或者sessiontStorage） 好久没用vuex了。 都是用公司大佬封装的存储数据的方法~~~~。&lt;br&gt;但是对于我们这些刚刚出去工作的人，或者在一些Vue项目的公司工作的话。 理解vuex原理是必不可少的。 那么接下来 想着分享vuex的原理。顺便帮自己复习一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>localStorage、sessionStorage、Cookie的区别及用法</title>
    <link href="http://yoursite.com/2018/12/13/localStorage%E3%80%81sessionStorage%E3%80%81Cookie%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/13/localStorage、sessionStorage、Cookie的区别及用法/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-27T07:14:25.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于在公司做vue项目。 不用vuex去存储数据。 都是基于localStorage、sessionStorage去封装的方法。 所以在网上去了解了一下他们的用法。和优势处。<br>提升下自己项目经验</p></blockquote><p>转载：<a href="https://segmentfault.com/a/1190000012057010" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012057010</a></p><p><strong>共同点：localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的</strong></p><h3 id="webstorage"><a href="#webstorage" class="headerlink" title="webstorage"></a>webstorage</h3><p>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。<br><a id="more"></a></p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。<strong>存放数据大小为一般为5MB</strong>,而且它仅在客户端（即浏览器）中保存，<strong>不参与和服务器的通信</strong>。</p><h5 id="localStorage的优势"><a href="#localStorage的优势" class="headerlink" title="localStorage的优势"></a>localStorage的优势</h5><p>1、localStorage拓展了cookie的4K限制</p><p>2、localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，<strong>不参与和服务器的通信</strong>。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。</p><p><strong>localStorage和sessionStorage使用时使用相同的API：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value”</span><br><span class="line"></span><br><span class="line">localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。</span><br><span class="line"></span><br><span class="line">localStorage.clear();​//清空localStorage中所有信息</span><br></pre></td></tr></table></figure></p><p>简单的举个例子来了解一下他们的用法<br>仿一下京东官网顶部的广告关闭，效果为第一次进入官网会出现广告，然后点击关闭，刷新网页不会再显示广告，但是当清除localStorage存入的数据，刷新网页会再显示广告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;header-a&quot;&gt;</span><br><span class="line">        &lt;a href=&quot;&quot;&gt;&lt;/a&gt;</span><br><span class="line">        &lt;i class=&quot;close&quot;&gt;x&lt;/i&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt; </span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">function haxi()&#123;</span><br><span class="line">        //判断localStorage里有没有isClose</span><br><span class="line">        if(localStorage.getItem(&quot;isClose&quot;))&#123;             </span><br><span class="line">            $(&quot;.header&quot;).hide();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $(&quot;.header&quot;).show();</span><br><span class="line">        &#125;</span><br><span class="line">        //点击关闭隐藏图片存取数据</span><br><span class="line">        $(&quot;.close&quot;).click(function()&#123;</span><br><span class="line">            $(&quot;.header&quot;).fadeOut(1000);</span><br><span class="line"></span><br><span class="line">            localStorage.setItem(&quot;isClose&quot;, &quot;1&quot;); </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    haxi();</span><br></pre></td></tr></table></figure></p><p>在项目里。 经常把一些弹框的判断。 存进这里面。 好让客户在选择之后。不再提示。<br>或者从一个页面做出了一个操作之后。 把该页面的数据存进storage。 然后在其它页面。 读取该数据。 起到了一个相当于vuex的存储的效果</p><h4 id="作用域不同"><a href="#作用域不同" class="headerlink" title="作用域不同"></a>作用域不同</h4><p>不同浏览器无法共享localStorage或sessionStorage中的信息。<strong>相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）</strong>，<strong>但是不同页面或标签页间无法共享sessionStorage的信息</strong>。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>生命期为只在<strong>设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</strong>。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果<strong>使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装</strong>，源生的Cookie接口不友好(<a href="http://www.jb51.net/article/6.." target="_blank" rel="noopener">http://www.jb51.net/article/6..</a>.<br>)。<br>用法和LoadStorage一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Cookie方法</span><br><span class="line">&lt;script src=&quot;../js/cookie.js&quot;&gt;&lt;/script&gt;//Cookie函数自己封装引入</span><br><span class="line">function haxi()&#123;</span><br><span class="line">        if(getCookie(&quot;isClose&quot;))&#123;             </span><br><span class="line">            $(&quot;.header&quot;).hide();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $(&quot;.header&quot;).show();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        $(&quot;.close&quot;).click(function()&#123;</span><br><span class="line">            $(&quot;.header&quot;).fadeOut(1000);</span><br><span class="line"></span><br><span class="line">            setCookie(&quot;isClose&quot;, &quot;1&quot;,&quot;s10&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    haxi();</span><br></pre></td></tr></table></figure></p><h4 id="cookie的优点：具有极高的扩展性和可用性"><a href="#cookie的优点：具有极高的扩展性和可用性" class="headerlink" title="cookie的优点：具有极高的扩展性和可用性"></a>cookie的优点：具有极高的扩展性和可用性</h4><blockquote><p>1.通过良好的编程，控制保存在cookie中的session对象的大小。<br>2.通过加密和安全传输技术，减少cookie被破解的可能性。<br>3.只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失。<br>4.控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就   是一个过期的cookie。</p></blockquote><h4 id="cookie的缺点"><a href="#cookie的缺点" class="headerlink" title="cookie的缺点"></a>cookie的缺点</h4><blockquote><p>1.cookie的<strong>长度和数量的限制</strong>。每个domain最多只能有<strong>20条cookie</strong>，每个cookie长度不能超过<strong>4KB</strong>。否则会被截掉。<br>2.<strong>安全性问题</strong>。如果cookie被人拦掉了，那个人就可以获取到所有session信息。<strong>加密的话也不起什么作用</strong>。<br>3.<strong>有些状态不可能保存在客户端</strong>。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于在公司做vue项目。 不用vuex去存储数据。 都是基于localStorage、sessionStorage去封装的方法。 所以在网上去了解了一下他们的用法。和优势处。&lt;br&gt;提升下自己项目经验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转载：&lt;a href=&quot;https://segmentfault.com/a/1190000012057010&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000012057010&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共同点：localStorage、sessionStorage、Cookie共同点：都是保存在浏览器端，且同源的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;webstorage&quot;&gt;&lt;a href=&quot;#webstorage&quot; class=&quot;headerlink&quot; title=&quot;webstorage&quot;&gt;&lt;/a&gt;webstorage&lt;/h3&gt;&lt;p&gt;webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js数据类型与检测</title>
    <link href="http://yoursite.com/2018/12/10/blog5/"/>
    <id>http://yoursite.com/2018/12/10/blog5/</id>
    <published>2018-12-10T07:40:22.900Z</published>
    <updated>2018-12-10T08:30:08.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在JavaScript中有哪些数据类型"><a href="#在JavaScript中有哪些数据类型" class="headerlink" title="在JavaScript中有哪些数据类型?"></a>在JavaScript中有哪些数据类型?</h1><p>JavaScript中的数据类型有6种：<br>基础数据类型5种：<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>undefined</code>、<code>null</code>、<br>复杂数据类型1种：<code>Object</code>、<br>如果在ES6中，新增了一种symbol类型，表示独一无二的值。并且symbol类型在初始化的时候不需要使用new操作符。</p><a id="more"></a><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><ul><li>除了以下值: undefined null false 0 NaN “” 或者’ ‘其他值都视为true。</li><li>空数组和空对象都是true。</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>字符串默认只能写在一行内，分成多行将会报错，如果必须，要在每一行的结尾使用反斜杆，但反斜杆后不能有诸如空格的其他字符。</li><li>连接运算符 + 可以连接多个单行字符串，将长字符串拆成多行书写。或者用es6的 <code>${}</code>字符串模板。</li><li>length属性返回字符串长度。</li><li>由于历史原因，JavaScript使用Unicode字符集。</li></ul><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul><li>JavaScript内部，所有数字都是以64位浮点数形式存储，整数也是。</li><li>JavaScript能够表示的数值范围是2^-1023到2^1024，超出的范围的数无法表示。</li><li>溢出能够表示的范围会返回Infinity（正数）或者0（负数）</li><li>数值可以有多种表示方法，字面形式和科学计数法。字面形式：35 0xFF(十六进制) 123e。</li><li>除以下情况外都采用字面形式表示，小数点前数字多于21位或后的零多于5个。</li><li>有四种进制来表示字面量：十进制 十六进制 八进制 二进制。</li><li>属于number类型的特殊数值：-0 +0 NaN 正负Infinity。</li><li>NaN参与的绝大部分运算都会得到诸如NaN false 这样的答案。</li><li>数值相关的全局方法 parseInt() parseFloat() isNaN() isFinite()</li></ul><h2 id="null-amp-undefined"><a href="#null-amp-undefined" class="headerlink" title="null &amp; undefined"></a>null &amp; undefined</h2><ul><li>都表示没有，在真值判断中都是false，null == undefined，null !== undefined</li><li>二者的来由很有历史原因，最开始null用于标识对象为空，这也是现在tyepof null //object的原因，之后又添加了一个undefined类型。</li><li>二者的区别，null是一个表示‘空’的对象，转为数值时为0，undefined 是一个表示此处无定义的原始值，转为数值时为NaN。</li></ul><h2 id="三大引用类型"><a href="#三大引用类型" class="headerlink" title="三大引用类型"></a>三大引用类型</h2><p>1.Object类型</p><p>我们看到的大多数类型值都是Object类型的实例，创建Object实例的方式有两种。</p><p>第一种是使用new操作符后跟Object构造函数，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"Micheal"</span>;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">24</span>;</span><br></pre></td></tr></table></figure><p>第二种方式是使用对象字面量表示法，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"></span><br><span class="line">　　name : <span class="string">"Micheal"</span>,</span><br><span class="line"></span><br><span class="line">　　age : <span class="number">24</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.Array类型</p><p>数组的每一项可以用来保存任何类型的数据，也就是说，可以用数组的第一个位置来保存字符串，第二个位置保存数值，第三个位置保存对象….另外，数组的大小是可以动态调整的。</p><p>创建数组的基本方式有两种</p><p>第一种是使用Array构造函数，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>);</span><br></pre></td></tr></table></figure><p>第二种是使用数组字面量表示法，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"yellow"</span>];</span><br></pre></td></tr></table></figure><p>3 Function类型</p><p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。函数通常是使用函数声明语法定义的，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> num1 + num2;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这和使用函数表达式定义函数的方式相差无几。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> sum1 + sum2;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>js按照存储方式分为值类型和引用类型,下一篇文章会讲到<code>浅拷贝深拷贝</code>。</p><h1 id="如何对数据类型进行判断？"><a href="#如何对数据类型进行判断？" class="headerlink" title="如何对数据类型进行判断？"></a>如何对数据类型进行判断？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> (<span class="literal">true</span>);                <span class="comment">//"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="string">"xwj"</span>);               <span class="comment">//"string"</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="number">10</span>);                  <span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="literal">undefined</span>);           <span class="comment">//"undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="literal">null</span>);                <span class="comment">//"object"</span></span><br><span class="line"><span class="keyword">typeof</span> (&#123;&#125;);                  <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><p>对于普通的数据类型来说，只需要使用typeof来进行判断就可以来，数据类型有6种，typeofde返回的值也有6种(在es6中是7种，包括symbol类型的返回值)，但是在typeof的返回值里面，null和Object返回的都是Object，而其余的都是对应的字符串，包括function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> a;                   <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure><h2 id="typeof后面经常会跟一个（），这对括号可否省略？"><a href="#typeof后面经常会跟一个（），这对括号可否省略？" class="headerlink" title="typeof后面经常会跟一个（），这对括号可否省略？"></a>typeof后面经常会跟一个（），这对括号可否省略？</h2><p>先想想typeof到底是什么？它的后面经常跟一对（），看起来确实有点像一个函数，但其实不然，typeof它是一个一元运算符，和+ - * / 是一样的，所以typeof后面是可以不跟（）的，加（）只是为了看起来方便，不过这也造成了一些误解，但它就是一个一元运算符。</p><p>一元运算符有很高的优先级，即使我们做多个 &amp;&amp; || 的逻辑判断时，typeof依然可以连着写，而不需要使用（）把每一个typeof包裹起来</p><h2 id="那么如何对Object类型进行判断？"><a href="#那么如何对Object类型进行判断？" class="headerlink" title="那么如何对Object类型进行判断？"></a>那么如何对Object类型进行判断？</h2><p>其实对Object判断主要是区分某个对象是否为数组，有以下方法：</p><p>1.使用instanceof判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>2.使用原型链上的constructor判断</p><p>console.log(a.<strong>proto</strong>.constructor===Array);   //true</p><p>这两种方法，看上去不错，但是实际上还是有些漏洞的，当我们的页面中存在多个frame，并且我们的判断是在两个iframe之间的时候，就很有可能出现问题了。由于每个iframe都属于自己的window对象，跨frame实例化的对象彼此是不共享原型链的，因此导致上述检测代码失效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);          <span class="comment">//创建iframe</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);                      <span class="comment">//添加到body中</span></span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length<span class="number">-1</span>].Array;   <span class="comment">//将xArray指向第二个iframe的引用</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);                            <span class="comment">// 声明数组[1,2,3]</span></span><br><span class="line">alert(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                            <span class="comment">// false</span></span><br><span class="line">alert(arr.constructor === <span class="built_in">Array</span>);                       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>还有两种更值得推荐的方法：</p><p>3.使用Array.isArray() 方法判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(a));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5加入了 Array.isArray() 方法，可以准确地检测一个值是否为数组。但是它有个缺点就是不支持IE8之前的版本，不过现在连淘宝都放弃了对IE8以下浏览器的支持，这个问题大概可以忽略</p><p>4.使用Object.prototype.toString.call()方法判断</p><p>这是一种无懈可击的判断数组的方法，所有typeof返回值为”object”的对象都有一个内置属性：<code>[[Class]]</code></p><p>Object.prototype.toString()获取到这个内置属性，然后根据它返回类似于”[object Array]”的字符串作为结果，利用这个方法，再配合call改变toString的this引用为待检测的对象，我们可以取得任何对象的内部属性[[Class]]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a));     <span class="comment">//[Object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(b));     <span class="comment">//[Object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(c));     <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>Object.prototype.toString方法在ECMAScript 3中规范中就存在，也不存在兼容性问题。</p><p>本文总结：js数据类型虽然是基础，但面试题也经常出现，偶尔回来温习一下巩固下基础对自己的发展也是有好处的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在JavaScript中有哪些数据类型&quot;&gt;&lt;a href=&quot;#在JavaScript中有哪些数据类型&quot; class=&quot;headerlink&quot; title=&quot;在JavaScript中有哪些数据类型?&quot;&gt;&lt;/a&gt;在JavaScript中有哪些数据类型?&lt;/h1&gt;&lt;p&gt;JavaScript中的数据类型有6种：&lt;br&gt;基础数据类型5种：&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;br&gt;复杂数据类型1种：&lt;code&gt;Object&lt;/code&gt;、&lt;br&gt;如果在ES6中，新增了一种symbol类型，表示独一无二的值。并且symbol类型在初始化的时候不需要使用new操作符。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化总结</title>
    <link href="http://yoursite.com/2018/12/07/blog4/"/>
    <id>http://yoursite.com/2018/12/07/blog4/</id>
    <published>2018-12-07T08:28:48.847Z</published>
    <updated>2018-12-07T08:56:28.534Z</updated>
    
    <content type="html"><![CDATA[<p>总结一波前端性能优化,传说中的雅虎军规，其实前端小白的我还不知道啥是雅虎军规，上网找了一些前端优化的问题才看到，百度一波猛然大悟，既然有前人给我们填坑，那肯定是要站在巨人的肩膀上去跳坑啦。</p><p>本文简单罗列了雅虎军规（35条），再加上本人的一些理解和看法。<br><a id="more"></a></p><h1 id="雅虎军规"><a href="#雅虎军规" class="headerlink" title="雅虎军规"></a>雅虎军规</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">尽量减少 HTTP 请求个数——须权衡</span><br><span class="line">使用 CDN（内容分发网络）</span><br><span class="line">为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性。</span><br><span class="line">避免空的 src 和 href</span><br><span class="line">使用 gzip 压缩内容</span><br><span class="line">把 CSS 放到顶部</span><br><span class="line">把 JS 放到底部</span><br><span class="line">避免使用 CSS 表达式</span><br><span class="line">将 CSS 和 JS 放到外部文件中</span><br><span class="line">减少 DNS 查找次数</span><br><span class="line">精简 CSS 和 JS</span><br><span class="line">避免跳转</span><br><span class="line">剔除重复的 JS 和 CSS</span><br><span class="line">配置 ETags</span><br><span class="line">使 AJAX 可缓存</span><br><span class="line">尽早刷新输出缓冲</span><br><span class="line">使用 GET 来完成 AJAX 请求</span><br><span class="line">延迟加载</span><br><span class="line">预加载</span><br><span class="line">减少 DOM 元素个数</span><br><span class="line">根据域名划分页面内容</span><br><span class="line">尽量减少 iframe 的个数</span><br><span class="line">避免 404</span><br><span class="line">减少 Cookie 的大小</span><br><span class="line">使用无 cookie 的域</span><br><span class="line">减少 DOM 访问</span><br><span class="line">开发智能事件处理程序</span><br><span class="line">用&lt;link&gt;代替 @import</span><br><span class="line">避免使用滤镜</span><br><span class="line">优化图像</span><br><span class="line">优化 CSS Spirite</span><br><span class="line">不要在 HTML 中缩放图像——须权衡</span><br><span class="line">favicon.ico要小而且可缓存</span><br><span class="line">保持单个内容小于25K</span><br><span class="line">打包组件成复合文本</span><br></pre></td></tr></table></figure><p>1、尽量减少HTTP请求个数——须权衡</p><p>合并图片（如css sprites，内置图片使用数据）、合并CSS、JS，这一点很重要，但是要考虑合并后的文件体积。</p><p>2、使用CDN（内容分发网络）</p><p>这里可以关注CDN的三类实现：镜像、高速缓存、专线，以及智能路由器和负载均衡；</p><p>3、为文件头指定Expires或Cache-Control，使内容具有缓存性。</p><p>区分静态内容和动态内容，避免以后页面访问中不必要的HTTP请求。</p><p>4、避免空的src和href</p><p>留意具有这两个属性的标签如link，script，img，iframe等；</p><p>5、使用gzip压缩内容</p><p>Gzip压缩所有可能的文件类型以来减少文件体积</p><p>6、把CSS放到顶部</p><p>实现页面有秩序地加载，这对于拥有较多内容的页面和网速较慢的用户来说更为重要，同时，HTML规范清楚指出样式表要放包含在页面的<head><meta name="generator" content="Hexo 3.8.0">区域内；</head></p><p>7、把JS放到底部</p><p>HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个，而问题在于脚本阻止了页面的平行下载，即便是主机名不相同</p><p>8、避免使用CSS表达式</p><p>页面显示和缩放，滚动、乃至移动鼠标时，CSS表达式的计算频率是我们要关注的。可以考虑一次性的表达式或者使用事件句柄来代替CSS表达式。</p><p>9、将CSS和JS放到外部文件中</p><p>我们需要权衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处的折中点。</p><p>10、减少DNS查找次数</p><p>我们需要权衡减少 DNS查找次数和保持较高程度并行下载两者之间的关系。</p><p>11、精简CSS和JS</p><p>目的就是减少下载的文件体积，可考虑压缩工具JSMin和YUICompressor。</p><p>12、避免跳转</p><p>为了确保“后退”按钮可以正确地使用，使用标准的 3XXHTTP状态代码；同域中注意避免反斜杠 “/” 的跳转；<br>跨域使用 Alias或者 mod_rewirte建立 CNAME（保存一个域名和另外一个域名之间关系的DNS记录）</p><p>13、剔除重复的JS和CSS</p><p>重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。</p><p>14、配置ETags</p><p>Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内 容”，包括图片、脚本、样式表等），是比last-modified date更更加灵活的机制，单位时间内文件被修过多次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载。</p><p>15、使AJAX可缓存</p><p>利用时间戳，更精巧的实现响应可缓存与服务器数据同步更新。</p><p>16、尽早刷新输出缓冲</p><p>尤其对于css，js文件的并行下载更有意义</p><p>17、使用GET来完成AJAX请求</p><p>当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。在url小于2K时使用GET获取数据时更加有意义。</p><p>18、延迟加载</p><p>确定页面运行正常后，再加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等。</p><p>19、预加载</p><p>关注下无条件加载，有条件加载和有预期的加载。</p><p>20、减少DOM元素个数</p><p>使用更适合或者在语意是更贴切的标签，要考虑大量DOM元素中循环的性能开销。</p><p>21、根据域名划分页面内容</p><p>很显然， 是最大限度地实现平行下载</p><p>22、尽量减少iframe的个数</p><p>考虑即使内容为空，加载也需要时间，会阻止页面加载，没有语意，注意iframe相对于其他DOM元素高出1-2个数量级的开销，它会在典型方式下阻塞onload事件，IE和Firefox中主页面样式表会阻塞它的下载。</p><p>23、避免404</p><p>HTTP请求时间消耗是很大的，有些站点把404错误响应页面改为“你是不是要找***”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。</p><p>24、减少Cookie的大小</p><p>去除不必要的coockie<br>使coockie体积尽量小以减少对用户响应的影响<br>注意在适应级别的域名上设置coockie以便使子域名不受影响<br>设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。</p><p>25、使用无cookie的域</p><p>确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。</p><p>26、减少DOM访问</p><p>缓存已经访问过的有关元素<br>线下更新完节点之后再将它们添加到文档树中<br>避免使用JavaScript来修改页面布局</p><p>27、开发智能事件处理程序</p><p>有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。<br>你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。<br>你可能会希望用DOMContentLoaded事件来代替 事件应用程序中的onAvailable方法。</p><p>28、用&lt; link &gt;代替@import</p><p>在IE中，页面底部@import和使用&lt; link &gt;作用是一样的，因此最好不要使用它。</p><p>29、避免使用滤镜</p><p>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</p><p>30、优化图像</p><p>尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）</p><p>31、优化CSS Spirite</p><p>在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；<br>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；<br>便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100×100的图片为1万像素，而1000×1000就是100万像素。</p><p>32、不要在HTML中缩放图像——须权衡</p><p>不要为了在HTML中设置长宽而使用比实际需要大的图片。</p><p>33、favicon.ico要小而且可缓存</p><p>favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。</p><p>因此，为了减少favicon.ico带来的弊端，要做到：<br>文件尽量地小，最好小于1K<br>在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。<br>Imagemagick可以帮你创建小巧的favicon。</p><p>34、保持单个内容小于25K</p><p>因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要。</p><p>35、打包组件成复合文本</p><p>页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规 则时，首先要确定用户代理是否支持（iPhone就不支持）。</p><h1 id="使用-Webpack-优化项目"><a href="#使用-Webpack-优化项目" class="headerlink" title="使用 Webpack 优化项目"></a>使用 Webpack 优化项目</h1><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一波前端性能优化,传说中的雅虎军规，其实前端小白的我还不知道啥是雅虎军规，上网找了一些前端优化的问题才看到，百度一波猛然大悟，既然有前人给我们填坑，那肯定是要站在巨人的肩膀上去跳坑啦。&lt;/p&gt;
&lt;p&gt;本文简单罗列了雅虎军规（35条），再加上本人的一些理解和看法。&lt;br&gt;
    
    </summary>
    
      <category term="前端优化" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>在公司项目和自己实战项目的GIT干货操作</title>
    <link href="http://yoursite.com/2018/12/06/%E5%9C%A8%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E5%92%8C%E8%87%AA%E5%B7%B1%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%9A%84GIT%E5%B9%B2%E8%B4%A7%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/12/06/在公司项目和自己实战项目的GIT干货操作/</id>
    <published>2018-12-06T02:19:41.000Z</published>
    <updated>2018-12-27T07:15:12.397Z</updated>
    
    <content type="html"><![CDATA[<!-- **修改仓库参考**:https://blog.csdn.net/asdfsfsdgdfgh/article/details/54981823 --><p>本博主会在以后的日子里 慢慢的分享出我遇到的困难~ 请期待~<br>由于示范连接码云的图片有点多。 本博主也太会弄。 所以有关连接码云的操作，可以上网查。 这个主要讲GIT操作<br><a id="more"></a><br><strong>我在网上看了下，也有其它比较好的GIT操作。 例如<a href="https://blog.csdn.net/youzhouliu/article/details/78952453这个博主的，写的也比较详细。下面写的是本人的经验。" target="_blank" rel="noopener">https://blog.csdn.net/youzhouliu/article/details/78952453这个博主的，写的也比较详细。下面写的是本人的经验。</a> 如果还有其它难题，可以看看这个博主的处理</strong></p><h3 id="git创建版本库—公司的项目是用gitlab仓库的。-本人的项目是用码云保存代码的。-下面的介绍用码云上的操作来介绍"><a href="#git创建版本库—公司的项目是用gitlab仓库的。-本人的项目是用码云保存代码的。-下面的介绍用码云上的操作来介绍" class="headerlink" title="git创建版本库—公司的项目是用gitlab仓库的。 本人的项目是用码云保存代码的。 下面的介绍用码云上的操作来介绍"></a>git创建版本库—公司的项目是用gitlab仓库的。 本人的项目是用码云保存代码的。 下面的介绍用码云上的操作来介绍</h3><p>外部连接提供：<a href="https://blog.csdn.net/gusy5188/article/details/80360096" target="_blank" rel="noopener">https://blog.csdn.net/gusy5188/article/details/80360096</a> 连接码云</p><blockquote><p>补充一下。里面没有介绍.ssh-rsa在哪，不用GIT去查的话，可以直接在露肩路径  这个文件在C:\Users\Administrator.ssh 中的<strong>id_rsa.pub</strong>文件里面。 可以复制内容在码云的SSH公钥中。 就是连接成功了。 接下来就是配置其它基本信息</p></blockquote><h3 id="GIT-的基本操作"><a href="#GIT-的基本操作" class="headerlink" title="GIT 的基本操作"></a>GIT 的基本操作</h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1 创建数据库"></a>1 创建数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git init //在一个文件目录执行该指令，会把该目录快速设置成Git的代码仓库。</span><br><span class="line">Git clone //从远程服务器clone工程，也会创建一个代码仓库。</span><br></pre></td></tr></table></figure><h4 id="2-提交修改"><a href="#2-提交修改" class="headerlink" title="2 提交修改"></a>2 提交修改</h4><p>git status  查看当前仓库状态。会提示那些文件发生修改，哪些内容需要add&amp;commit。<br>git add .   把本地修改的文件，加入到本地的缓存区 （这里代表的是全部修改文件）<br>git add 文件名   添加单个文件<br>git commit -m “这次添加文件的注释”  将add的文件添加注释并且提交到代码仓库<br>git push origin master(分支)</p><h3 id="在git-Bash-中修改远程的仓库地址"><a href="#在git-Bash-中修改远程的仓库地址" class="headerlink" title="在git Bash 中修改远程的仓库地址"></a>在git Bash 中修改远程的仓库地址</h3><p>在我的开发项目中， 会每过几个迭代，就会<strong>更新远程的用户名</strong>。要我们用<strong>这个新的用户名</strong>去管理git Lab上的<strong>代码</strong>。<br>所以有时候系统不自动更新git bash上的远程账号的话，会无法拉取和提交。所以要<strong>修改远程的用户名</strong>。<br>还有对于一些项目会迁移， 作为<strong>git仓库的服务器IP地址变了</strong>。 本地代码挺多，重新检出太占时间，可以修改一个什么配置让我本地仓库和新的远程仓库<br>下面是解决方法：</p><h4 id="方法一通过命令直接修改远程地址"><a href="#方法一通过命令直接修改远程地址" class="headerlink" title="方法一通过命令直接修改远程地址"></a>方法一通过命令直接修改远程地址</h4><p>1进入你们项目目录<br>2git remote 查看所有远程仓库， git remote xxx 查看指定远程仓库地址<br>3git remote set-url origin <a href="http://xxxxxx/xxxxx.git" target="_blank" rel="noopener">http://xxxxxx/xxxxx.git</a></p><p>然后当你git pull yourorigin branch 的时候 他就会让你重新输入你在gitlab(github)上的user.name和password。</p><h4 id="方法二-通过命令先删除再添加远程仓库"><a href="#方法二-通过命令先删除再添加远程仓库" class="headerlink" title="方法二 通过命令先删除再添加远程仓库"></a>方法二 通过命令先删除再添加远程仓库</h4><p>1.进入你们项目目录<br>git remote 查看所有远程仓库， git remote xxxx 查看指定远程仓库地址<br>git remote rm origin<br>git remote add origin <a href="http://xxxxxx/xxxxx.git" target="_blank" rel="noopener">http://xxxxxx/xxxxx.git</a></p><h4 id="方法三-通过第三方git客户端修改。"><a href="#方法三-通过第三方git客户端修改。" class="headerlink" title="方法三 通过第三方git客户端修改。"></a>方法三 通过第三方git客户端修改。</h4><p>以SourceTree为例，点击 仓库 -&gt; 仓库配置 -&gt; 远程仓库 即可管理此项目中配置的所有远程仓库， 而且这个界面最下方还可以点击编辑配置文件。可以实现远程仓库的更换。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 
**修改仓库参考**:https://blog.csdn.net/asdfsfsdgdfgh/article/details/54981823 --&gt;
&lt;p&gt;本博主会在以后的日子里 慢慢的分享出我遇到的困难~ 请期待~&lt;br&gt;由于示范连接码云的图片有点多。 本博主也太会弄。 所以有关连接码云的操作，可以上网查。 这个主要讲GIT操作&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>亮眼操作：关于vux的v-transfer-dom的指令</title>
    <link href="http://yoursite.com/2018/12/06/Vue%E6%93%8D%E4%BD%9C%EF%BC%9A%E5%85%B3%E4%BA%8Evux%E7%9A%84v-transfer-dom%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/06/Vue操作：关于vux的v-transfer-dom的指令/</id>
    <published>2018-12-06T02:19:41.000Z</published>
    <updated>2018-12-27T07:14:32.001Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在我自己的移动端项目实战项目中， 我在封装组件的时候，偶尔会弹出很多框，列如还有一些遮罩搭配弹窗的东西。 往往，我们为了复用性更高。 我们会封装成<strong>组件</strong>。<br>问题来了， 我们要怎么定位到body的宽度，而去无视父组件的宽度和高度呢？ 这个时候，<strong>vux的v-transfer-dom</strong>指令， 就会让我们更容易的去封装这些弹框组。让代码更加简单<br><a id="more"></a><br>在我们开发的过程中，我们用到了Vux,而且遇到 <strong>Alert</strong> <strong>Popup</strong> <strong>XDialog</strong>等组件，我们可以用v-transfer-dom实现移动到body下。</p></blockquote><blockquote><p>必须有一个 <strong>div</strong> 作为占位元素否则会出错</p></blockquote><h4 id="1使用-注册局部指令"><a href="#1使用-注册局部指令" class="headerlink" title="1使用  注册局部指令"></a>1使用  注册局部指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; TransferDom &#125; from &apos;vux&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    TransferDom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面注意是在Vue 中的directives中引用这个指令</p><h4 id="模板使用"><a href="#模板使用" class="headerlink" title="模板使用"></a>模板使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-transfer-dom&gt;</span><br><span class="line">  &lt;popup v-model=&quot;show&quot;&gt;&lt;/popup&gt;</span><br><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><p>如果有博友想了解更多的关于移动端的布局。 现阶段的移动端的布局。 CSS可以去学习一下<strong>flex</strong>布局。 很适合现阶段的移动端布局</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在我自己的移动端项目实战项目中， 我在封装组件的时候，偶尔会弹出很多框，列如还有一些遮罩搭配弹窗的东西。 往往，我们为了复用性更高。 我们会封装成&lt;strong&gt;组件&lt;/strong&gt;。&lt;br&gt;问题来了， 我们要怎么定位到body的宽度，而去无视父组件的宽度和高度呢？ 这个时候，&lt;strong&gt;vux的v-transfer-dom&lt;/strong&gt;指令， 就会让我们更容易的去封装这些弹框组。让代码更加简单&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于CSS3中的 box-sizing border-box;</title>
    <link href="http://yoursite.com/2018/12/05/CSS3%E4%B8%AD%E7%9A%84&#39;&#39;%20box-sizing%20border-box;&#39;%E5%BE%AE%E5%A6%99%E4%B9%8B%E5%A4%84/"/>
    <id>http://yoursite.com/2018/12/05/CSS3中的&#39;&#39; box-sizing border-box;&#39;微妙之处/</id>
    <published>2018-12-05T04:00:00.000Z</published>
    <updated>2018-12-27T07:13:43.613Z</updated>
    
    <content type="html"><![CDATA[<p>在最近我在做自己的项目的过程之中， 在CSS中。我遇到了 box-sizing border-box;我通过用这个 box-sizing border-box;，简化了不少代码。 所以想在这通过网上的一些文章，和自己的一些理解来介绍一下</p><h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><p>指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外</p><h3 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h3><p>指定宽度和高度（最小/最大属性）确定元素边框box。也就是说，对元素指定<strong>宽度</strong>和<strong>高度</strong>包括padding和border的指定。<strong>内容的宽度和高度减去各自双方该边框和填充的宽度从指定的”宽度”和”高度”属性计算</strong></p><h3 id="inherit"><a href="#inherit" class="headerlink" title="inherit"></a>inherit</h3><p>指定box-sizing属性的值，应该从父元素继承</p><p>对于boder-box的计算方法<br>border-box  width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。<br>这里的维度计算为： width = border + padding + 内容的  width， height = border + padding + 内容的 height。<br><a id="more"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>一般写页面对ui设计好的来说，我们最好使用这个属性，这样对整体布局很有好处，不然，页面很容易出现问题。</strong></p><hr><blockquote><p>便于朋友记忆。 加多一个overflow:hidden的用法在此文章</p></blockquote><h3 id="overflow-hidden的作用是"><a href="#overflow-hidden的作用是" class="headerlink" title="overflow:hidden的作用是"></a>overflow:hidden的作用是</h3><p><strong>1.隐藏溢出的东西</strong><br><code></code></p><pre><code>#wai{ width:200px;  background:#000; height:200px; border:2px blue solid; }#nei { float:left; width:300px; height:300px; background:red;}</code></pre><p><code></code><br>当我们没有给wai这个div设置高度的时候，nei这个div的高度，就会撑开wai这个div，而在另一个方面，我们要注意到的是，当我们<br>给wai这个div加上一个高度值，那么无论nei这个div的高度是多少，wai这个高度都是我们设定的值。而当nei的高度超过wai的高度的时候，<br>超出的部分就会被隐藏。这就是隐藏溢出的含义!<br><strong>2.清楚浮动</strong><br>当nei这个div加上浮动这个属性的时候，在显示器的侧面，它已经脱离了wai这个div，也就是说，此时的nei的宽高是多少， 对于已经脱离了的wai来说，都是不起作用的。当我们全面的理解了浮动这个词的含义的时候，我们就理解overflow:hidden这个属性中的解释，清除浮动是什么意思了。也就是说，当我们给wai这个div加上overflow:hidden这个属性的时候，其中的nei等等带浮动属性的div的在这个立体的浮动已经被清除了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在最近我在做自己的项目的过程之中， 在CSS中。我遇到了 box-sizing border-box;我通过用这个 box-sizing border-box;，简化了不少代码。 所以想在这通过网上的一些文章，和自己的一些理解来介绍一下&lt;/p&gt;
&lt;h3 id=&quot;content-box&quot;&gt;&lt;a href=&quot;#content-box&quot; class=&quot;headerlink&quot; title=&quot;content-box&quot;&gt;&lt;/a&gt;content-box&lt;/h3&gt;&lt;p&gt;指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外&lt;/p&gt;
&lt;h3 id=&quot;border-box&quot;&gt;&lt;a href=&quot;#border-box&quot; class=&quot;headerlink&quot; title=&quot;border-box&quot;&gt;&lt;/a&gt;border-box&lt;/h3&gt;&lt;p&gt;指定宽度和高度（最小/最大属性）确定元素边框box。也就是说，对元素指定&lt;strong&gt;宽度&lt;/strong&gt;和&lt;strong&gt;高度&lt;/strong&gt;包括padding和border的指定。&lt;strong&gt;内容的宽度和高度减去各自双方该边框和填充的宽度从指定的”宽度”和”高度”属性计算&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;inherit&quot;&gt;&lt;a href=&quot;#inherit&quot; class=&quot;headerlink&quot; title=&quot;inherit&quot;&gt;&lt;/a&gt;inherit&lt;/h3&gt;&lt;p&gt;指定box-sizing属性的值，应该从父元素继承&lt;/p&gt;
&lt;p&gt;对于boder-box的计算方法&lt;br&gt;border-box  width 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border: 10px solid black;} 导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。&lt;br&gt;这里的维度计算为： width = border + padding + 内容的  width， height = border + padding + 内容的 height。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flex布局-一个前端工程师必不可缺的布局</title>
    <link href="http://yoursite.com/2018/12/05/Flex%E5%B8%83%E5%B1%80-%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E4%B8%8D%E5%8F%AF%E7%BC%BA%E7%9A%84%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/12/05/Flex布局-一个前端工程师必不可缺的布局/</id>
    <published>2018-12-05T02:19:41.000Z</published>
    <updated>2018-12-27T07:13:58.894Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近项目中， 由于前端页面布局是页面小组做的。 我的小组的人忘记如何去布局了。<br>在此想介绍一下FLEX布局给你们认识。<br>作为web端和移动端的前流布局  <strong>Flex布局</strong><br><a id="more"></a><br>参考阮一峰的文章flex布局<br> 语法：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br> 实战：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p></blockquote><p>里面该有的都会有。 在下面 我讲解一下比较常用，然后到概念</p><h3 id="flex-1-让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容"><a href="#flex-1-让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容" class="headerlink" title="flex:1; 让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容"></a>flex:1; 让所有弹性盒模型对象的子元素都有相同的长度，忽略它们内部的内容</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近项目中， 由于前端页面布局是页面小组做的。 我的小组的人忘记如何去布局了。&lt;br&gt;在此想介绍一下FLEX布局给你们认识。&lt;br&gt;作为web端和移动端的前流布局  &lt;strong&gt;Flex布局&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
